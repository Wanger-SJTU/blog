<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/blog/2021/04/17/test/"/>
    <url>/blog/2021/04/17/test/</url>
    
    <content type="html"><![CDATA[<p>test blog</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BN及其变体</title>
    <link href="/blog/2021/04/17/2018-09-20-normalization%20layer/"/>
    <url>/blog/2021/04/17/2018-09-20-normalization%20layer/</url>
    
    <content type="html"><![CDATA[<ol><li>Batch norm 介绍  <a href="./batch norm.md">BN</a></li><li>IN介绍<a href="./instance norm.md">IN</a></li></ol><h2 id="Batch-Renormalization"><a href="#Batch-Renormalization" class="headerlink" title="Batch-Renormalization"></a>Batch-Renormalization</h2><ol><li><p>问题</p><p>batch norm原作者对其的优化，该方法保证了train和inference阶段的等效性，解决了非独立同分布和小minibatch的问题</p></li><li><p>算法</p><p> <img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/normalization-layer/1.jpg" alt="Batch-Renormalization"></p><p><code>r</code>和<code>d</code>首先通过minibatch计算出，但stop_gradient使得<strong>反传中<code>r</code>和<code>d</code>不被更新</strong>，因此r和d不被当做训练参数对待。试想如果r和d作为参数来更新，如下式所示：</p><p><img src="http://ww1.sinaimg.cn/large/007arC1sgy1g0wjh15lqkj30f502y0sq.jpg" alt=""></p></li></ol><p>   这样一来，就相当于在训练阶段也使用<code>moving averages</code>  $μ$和$σ$，这会引起梯度优化和normalization之间的冲突，优化的目的是通过对权重的scale和shift去适应一个minibatch，normalization则会抵消这种影响，<br>   而moving averages则消除了归一化后的激活对当前minibatch的依赖性，使得minibatch丧失了对每次权重更新方向的调整，从而使得权重尺度因normalization的抵消而无边界的增加却不会降低loss。而在前传中r和d的仿射变换修正了minibatch和普适样本的差异，使得该层的激活在inference阶段能得到更有泛化性的修正。</p><ol><li><h2 id="Weight-Normalization"><a href="#Weight-Normalization" class="headerlink" title="Weight-Normalization"></a>Weight-Normalization</h2></li></ol><h2 id="Layer-Norm"><a href="#Layer-Norm" class="headerlink" title="Layer Norm"></a>Layer Norm</h2><h2 id="Group-Norm"><a href="#Group-Norm" class="headerlink" title="Group Norm"></a>Group Norm</h2><h2 id="Ada-BN"><a href="#Ada-BN" class="headerlink" title="Ada-BN"></a>Ada-BN</h2><p>Ada-BN提出是为了解决域适应问题（Domain Adaption）问题。作者统计发现，对于源域的数据，通过BN层以后，可以达到很好的白化效果，但是由于目标和源域之间的分布差异，源域的BN层的统计值并不适应于目标域，因此可以通过替换源域模型的参数目标域参数的方法来进行域适应。</p><h2 id="Ada-IN"><a href="#Ada-IN" class="headerlink" title="Ada-IN"></a>Ada-IN</h2><h2 id="IBN"><a href="#IBN" class="headerlink" title="IBN"></a>IBN</h2><p>IBN-net 是将<code>resnet</code>中的BN替换成BN和IN。</p><p>ref:[<a href="https://zhuanlan.zhihu.com/p/33173246">https://zhuanlan.zhihu.com/p/33173246</a>]</p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始化方法-基本到kaiming</title>
    <link href="/blog/2021/04/17/2019-9-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95-%E5%9F%BA%E6%9C%AC%E5%88%B0kaiming/"/>
    <url>/blog/2021/04/17/2019-9-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95-%E5%9F%BA%E6%9C%AC%E5%88%B0kaiming/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么需要初始化"><a href="#为什么需要初始化" class="headerlink" title="为什么需要初始化"></a>为什么需要初始化</h3><p>初始化的原因，</p><ul><li>防止每一层的输出太大或者太小，导致梯度反向传播过程中，梯度爆炸或者梯度消失。</li><li>不能采用统一值得原因，因为统一值得初始化会使得每一层网络在不同通道学到得特征相同。</li></ul><p>上述原因都会导致，网络模型不能收敛。</p><h4 id="简单例子得说明"><a href="#简单例子得说明" class="headerlink" title="简单例子得说明"></a>简单例子得说明</h4><p>假如我们有一个输入<code>x</code> ，定义为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="hljs-number">512</span>)<br></code></pre></td></tr></table></figure><p><code>x</code>是`均值为 $0$，方差是 $1$ 的高斯分布。然后定义一个100层的神经网络（注：不包含激活函数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)<br>    x = a @ x<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br></code></pre></td></tr></table></figure><p>那么得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(tensor(nan),tensor(nan))<br></code></pre></td></tr></table></figure><p>输出已经是无穷大了。通过下面的代码，可以知道大概29层以后，输出就已经无法计算了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)<br>    x = a @ x<br>    <span class="hljs-keyword">if</span> torch.isnan(x.std()):<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 28</span><br></code></pre></td></tr></table></figure><p>既然输出太大，我们把神经网络的初始化变小一点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)*<span class="hljs-number">0.01</span><br>    x = a @ x<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment"># 0, 0</span><br></code></pre></td></tr></table></figure><p>那么得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">(tensor(<span class="hljs-number">0.</span>),tensor(<span class="hljs-number">0.</span>))<br></code></pre></td></tr></table></figure><p>这时候的输出就太小，没办法计算了。</p><h3 id="怎么找到合适的初始化方法"><a href="#怎么找到合适的初始化方法" class="headerlink" title="怎么找到合适的初始化方法"></a>怎么找到合适的初始化方法</h3><p>对于神经网络来说，前向传播过程就是矩阵运算，假设一层的输出为$y$</p><script type="math/tex; mode=display">y_i= \sum_{k=1}^{n-1}a_{i,k}x_k</script><p>$i$ 是矩阵 $\mathbf{m}$ 的行，$k$ 是矩阵 $\mathbf{m}$ 的列。python的计算代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">y[i] = <span class="hljs-built_in">sum</span>([c*d <span class="hljs-keyword">for</span> c,d <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(a[i], x)])<br></code></pre></td></tr></table></figure><p>可以证明，在给定的层，从标准正态分布初始化的输入$x$ 和权重矩阵 $a$ 的矩阵乘积平均具有非常接近输入<strong>连接数的平方根的标准偏差</strong>，在例子中是$\sqrt{512}$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">mean,var=<span class="hljs-number">0.</span>,<span class="hljs-number">0.</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>    x = torch.randn(<span class="hljs-number">512</span>)<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)<br>    y = a @ x<br>    mean += y.mean().item()<br>    var += y.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean().item()<br><span class="hljs-built_in">print</span>(mean()/<span class="hljs-number">10000</span>, math.sqrt(var/<span class="hljs-number">10000</span>))<br><span class="hljs-comment">#0.00889449315816164  22.629779825053976</span><br><span class="hljs-built_in">print</span>(math.sqrt(<span class="hljs-number">512</span>))<br><span class="hljs-comment"># 22.627416997969522</span><br><br>mean,var = <span class="hljs-number">0.</span>,<span class="hljs-number">0.</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>    x = torch.randn(<span class="hljs-number">512</span>)<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)<br>    b = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)<br>    y = a @ x<br>    z = b @ y<br>    mean += z.mean().item()<br>    var += z.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean().item()<br><span class="hljs-built_in">print</span>(mean/<span class="hljs-number">10000</span>, math.sqrt(var/<span class="hljs-number">10000</span>))<br><span class="hljs-comment">#0.6010947234869003 511.8684602024235</span><br></code></pre></td></tr></table></figure><p>如果我们根据如何定义矩阵乘法来看前向传播的过程：</p><p>为了计算 $y$，我们将输入 $x$ 的一个元素的乘以矩阵 $\mathbf{a}$ 的一列的512个乘积然后相加。在使用标准正态分布初始化$x$ 和 $a$ 的示例中，这$512$ 个数字中的每一个的平均值为 $0$，标准差为$1$。</p><blockquote><p><strong>经过一层网络运算以后，均值没变，方差扩大了$\sqrt{512}$倍。</strong></p></blockquote><p>因此在初始化的是，缩小$\sqrt{512}$倍，那么输出结果就能保证不<strong>爆炸</strong>了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">mean,var=<span class="hljs-number">0.</span>,<span class="hljs-number">0.</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>    x = torch.randn(<span class="hljs-number">512</span>)<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    y = a @ x<br>    mean += y.mean().item()<br>    var += y.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean().item()<br><span class="hljs-built_in">print</span>(mean/<span class="hljs-number">10000</span>, math.sqrt(var/<span class="hljs-number">10000</span>))<br><span class="hljs-comment">#0.00039810733370250094 1.0007971983717594</span><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    x = a @ x<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment">#tensor(-0.0048) tensor(1.2810)</span><br></code></pre></td></tr></table></figure><h3 id="Xavier-Initialization"><a href="#Xavier-Initialization" class="headerlink" title="Xavier Initialization"></a>Xavier Initialization</h3><p>上面介绍的情况是在不含有激活的函数情形，如果增加了激活函数，是否仍能保持不变呢？对于不同类型的激活函数，是不是有不同的表现呢？最开始用的激活函数多数为对称的，并且导数从中间到两边有递减为0。比如，常用的<code>tanh</code>和<code>sigmoid</code>函数。</p><p>下面的结果是在上面的例子中分别增加了，<code>tanh</code>和<code>sigmoid</code>函数的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#sigmoid</span><br>x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    x = torch.sigmoid( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment">#tensor(0.5057) tensor(0.1180)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#tanh</span><br>x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    x =  torch.tanh( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment">#tensor(-0.0051) tensor(0.0879)</span><br></code></pre></td></tr></table></figure><p>可以看到经过激活函数以后，函数方差明显变小了。在训练过程中这就会导致，导致梯度过小，使得训练难以进行。</p><p>上面用的是正态分布，如果采用均匀分布呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.Tensor(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>).uniform_(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    x =  torch.tanh( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment">#tensor(-3.8077e-26) tensor(1.2476e-24)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.Tensor(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>).uniform_(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    x =  torch.tanh( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment">#tensor(-1.) tensor(0.)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.Tensor(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>).uniform_(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    x =  torch.sigmoid( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment">#tensor(1.0000) tensor(3.8114e-06)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.Tensor(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>).uniform_(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    x =  torch.sigmoid( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment">#tensor(0.4934) tensor(0.0659)</span><br></code></pre></td></tr></table></figure><p>方差都出人意料的小。这就几乎不能学习到什么有用的特征了。</p><p>为此，Glorot and Bengio 提出了<code>Xavier initialization</code>的初始化方式</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>这种初始化方式是从随机均匀分布初始化神经网络的，均匀分布的范围是</p><script type="math/tex; mode=display">\pm \frac{\sqrt{6}}{\sqrt{n_i+n_{i+1}}}</script><p>这里的 $n<em>i$ 是输入神经元数目，$n</em>{i+1}$ 是输出神经元数目。</p><p>Glorot and Bengio 认为Xavier 初始化方法，可以在包含激活函数的神经网络中保持方差的变化很小。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/bolgs/Xavier.png" alt="img"></p><p>除此之外，同样证明了，传统方法在底层网络方差大，高层网络方差趋近于0的现象。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/bolgs/Xavier2.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xavier</span>(<span class="hljs-params">m,n</span>):</span><br>    <span class="hljs-keyword">return</span> torch.Tensor(m,n).uniform_(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)/math.sqrt(<span class="hljs-number">6.</span>/(m+n))<br><br>x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = xavier(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)<br>    x =  torch.tanh( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment">#tensor(0.0854) tensor(0.9933)</span><br>x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = xavier(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)<br>    x =  torch.sigmoid( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment">#tensor(0.4686) tensor(0.4976)</span><br></code></pre></td></tr></table></figure><h3 id="Kaiming-Initialization"><a href="#Kaiming-Initialization" class="headerlink" title="Kaiming Initialization"></a>Kaiming Initialization</h3><p>进来CV领域中，激活方法多是采用<code>Relu</code> 函数。对于这个函数。之前的初始化方法，又有哪些不一样？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    x = torch.relu(a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment"># tensor(4.6656e-16) tensor(6.7154e-16)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = xavier(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)<br>    x =  torch.relu( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment"># tensor(nan) tensor(nan)</span><br></code></pre></td></tr></table></figure><p>之前的初始化方法，对于<code>Relu</code>函数都不奏效了。那对于每一层来说，有什么变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">mean,var=<span class="hljs-number">0.</span>,<span class="hljs-number">0.</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>    x = torch.randn(<span class="hljs-number">512</span>)<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)/math.sqrt(<span class="hljs-number">512</span>)<br>    y = torch.relu(a @ x)<br>    mean += y.mean().item()<br>    var += y.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean().item()<br><br><span class="hljs-built_in">print</span>(mean/<span class="hljs-number">10000</span>, math.sqrt(var/<span class="hljs-number">10000</span>))<br><span class="hljs-comment">#9.01142036409378 15.991211348807246</span><br><span class="hljs-built_in">print</span>(math.sqrt(<span class="hljs-number">512</span>/<span class="hljs-number">2</span>))<br><span class="hljs-comment">#16.0</span><br></code></pre></td></tr></table></figure><p>可以看到，这时候的输出跟输入网络层数大小是有关系的。在下面的实验验证以下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">mean,var=<span class="hljs-number">0.</span>,<span class="hljs-number">0.</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>    x = torch.randn(<span class="hljs-number">512</span>)<br>    a = torch.randn(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)/math.sqrt(<span class="hljs-number">512</span>/<span class="hljs-number">2.</span>)<br>    y = torch.relu(a @ x)<br>    mean += y.mean().item()<br>    var += y.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>).mean().item()<br><br><span class="hljs-built_in">print</span>(mean/<span class="hljs-number">10000</span>, math.sqrt(var/<span class="hljs-number">10000</span>))<br><span class="hljs-comment">#0.5640919140070677 1.0003173674661943</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kaiming</span>(<span class="hljs-params">m,n</span>):</span><br>    <span class="hljs-keyword">return</span> torch.randn(m,n)*math.sqrt(<span class="hljs-number">2.</span>/m)<br><br>x = torch.randn(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    a = kaiming(<span class="hljs-number">512</span>,<span class="hljs-number">512</span>)<br>    x = torch.relu( a @ x)<br><span class="hljs-built_in">print</span>(x.mean(), x.std())<br><span class="hljs-comment"># tensor(0.8135) tensor(1.2431)</span><br></code></pre></td></tr></table></figure><p>对照本部分开始的结果<code>kaiming</code>方法在对于<code>Relu</code>函数更有优势。</p><p>下图给出了两种方法在一个30层CNN上的结果。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/bolgs/kaiming.png" alt="kaiming method"></p><hr><p><strong>来源</strong>  <a href="https://towardsdatascience.com/weight-initialization-in-neural-networks-a-journey-from-the-basics-to-kaiming-954fb9b47c79">Weight Initialization in Neural Networks: A Journey From the Basics to Kaiming</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>DL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Multi-path Learning for Object Pose Estimation Across Domains</title>
    <link href="/blog/2019/08/11/2019-8-11-Multi-path%20Learning%20for%20Object%20Pose%20Estimation%20Across%20Domains/"/>
    <url>/blog/2019/08/11/2019-8-11-Multi-path%20Learning%20for%20Object%20Pose%20Estimation%20Across%20Domains/</url>
    
    <content type="html"><![CDATA[<h1 id="Multi-path-Learning-for-Object-Pose-Estimation-Across-Domains"><a href="#Multi-path-Learning-for-Object-Pose-Estimation-Across-Domains" class="headerlink" title="Multi-path Learning for Object Pose Estimation Across Domains"></a>Multi-path Learning for Object Pose Estimation Across Domains</h1><h3 id="论文框架"><a href="#论文框架" class="headerlink" title="论文框架"></a>论文框架</h3><p><img src="../img/811/model.png" alt="models"></p><p>论文的模型思路来自于<a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Martin_Sundermeyer_Implicit_3D_Orientation_ECCV_2018_paper.pdf">Augmented Autoencoder (AAE) </a>。通过训练一个Autoencoder，来学习物体6D姿态的潜在信息。进而利用潜在编码进行姿态求解。<br>不同于AAE的是，这篇论文使用的是多路解码器，encoder部分输入是数据增强以后不同角度的RGB图像，解码部分则是每个物体设置一个解码器。</p><h3 id="AAE介绍"><a href="#AAE介绍" class="headerlink" title="AAE介绍"></a>AAE介绍</h3><p>定义输入图片 $\mathbf{x}\in \mathcal{R}^d$， 数据增强操作为 $f(\cdot)$, encoder为 $\Upsilon(\cdot)$, 潜变量为 $\mathbf{z}\in \mathcal{R}^m, (m \ll d)$， decoder 为 $\Lambda(\cdot)$. 重建图像 $\hat{\mathbf{x}}$</p><script type="math/tex; mode=display">\hat{\mathbf{x}}=\Lambda(\Upsilon(f(\mathbf{x})))=\Lambda\left(\Upsilon\left(x^{\prime}\right)\right)=\Lambda(\mathbf{z})</script><p>loss 通常为：</p><script type="math/tex; mode=display">\ell_{2}(\mathcal{B})=\sum_{i \in \mathcal{B}}\left\|\mathbf{x}_{i}-\hat{\mathbf{x}}_{i}\right\|_{2}=\sum_{i \in \mathcal{B}}\left\|\mathbf{x}_{i}-\Lambda\left(\Upsilon\left(f\left(\mathbf{x}_{i}\right)\right)\right)\right\|_{2}</script><h3 id="Multi-Path-Encoder-Decoder"><a href="#Multi-Path-Encoder-Decoder" class="headerlink" title="Multi-Path Encoder-Decoder"></a>Multi-Path Encoder-Decoder</h3><p>多路decoder的loss 定义为</p><script type="math/tex; mode=display">\begin{aligned} \ell_{m}(\tilde{\mathcal{B}}) &=\sum_{j=1}^{b} \sum_{k=1}^{n} \mathbb{I}\left(s_{j}=k\right)\left\|\mathbf{x}_{j}-\Lambda_{k}\left(\Upsilon\left(f\left(\mathbf{x}_{j}\right)\right)\right)\right\|_{2} \\ &=\sum_{j=1}^{b} \sum_{k=1}^{n} \mathbb{I}\left(s_{j}=k\right)\left\|\mathbf{x}_{j}-\Lambda_{k}\left(\mathbf{z}_{j}\right)\right\|_{2} \end{aligned}</script><p>其中$\mathbb{I}$是指示函数。</p><h3 id="Object-Pose-Estimation-Across-Domains"><a href="#Object-Pose-Estimation-Across-Domains" class="headerlink" title="Object Pose Estimation Across Domains"></a>Object Pose Estimation Across Domains</h3><h3 id="Iterative-Reﬁnement-of-Latent-Codes"><a href="#Iterative-Reﬁnement-of-Latent-Codes" class="headerlink" title="Iterative Reﬁnement of Latent Codes"></a>Iterative Reﬁnement of Latent Codes</h3><p><img src="../img/811/pose.png" alt="models"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>链表反转</title>
    <link href="/blog/2019/07/23/2019-7-23-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    <url>/blog/2019/07/23/2019-7-23-%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode-206-单链表反转"><a href="#leetcode-206-单链表反转" class="headerlink" title="leetcode 206 单链表反转"></a>leetcode 206 单链表反转</h2><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br></code></pre></td></tr></table></figure><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>首先设置<code>pre,cur,lat</code>三个指针<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">pre   cur  lat<br><span class="hljs-literal">null</span>   <span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><br>接着<code>cur.next = pre</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">pre   cur  lat<br><span class="hljs-literal">null</span> &lt;-<span class="hljs-number">1</span>    <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>接着<code>pre = cur，cur = lat，lat = lat.next</code><br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">      pre  cur  lat<br><span class="hljs-literal">null</span> &lt;-<span class="hljs-number">1</span>    <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><br>重复上述操作直到<code>lat=None</code>。<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache">                     <span class="hljs-attribute">pre</span>  cur  lat<br><span class="hljs-attribute">null</span> &lt;-<span class="hljs-number">1</span> &lt;- <span class="hljs-number">2</span> &lt;- <span class="hljs-number">3</span> &lt;- <span class="hljs-number">4</span>    <span class="hljs-number">5</span> -&gt; null<br></code></pre></td></tr></table></figure></p><p><strong>代码</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span><br>        pre = <span class="hljs-literal">None</span><br>        cur = head <br>        <span class="hljs-keyword">while</span> cur != <span class="hljs-literal">None</span>:<br>            cur.<span class="hljs-built_in">next</span>, pre, cur =  pre, cur,cur.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> pre<br></code></pre></td></tr></table></figure></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head</span>):</span><br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span> == <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> head<br>    node = self.reverseList(head.<span class="hljs-built_in">next</span>)<br>    head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head<br>    head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> node<br></code></pre></td></tr></table></figure><h2 id="leetcode-25-单链表-k组反转"><a href="#leetcode-25-单链表-k组反转" class="headerlink" title="leetcode 25 单链表-k组反转"></a>leetcode 25 单链表-k组反转</h2><blockquote><p>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code><br>当 <code>k = 2</code> 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code><br>当 <code>k = 3</code> 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>linkedList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STN_CTC</title>
    <link href="/blog/2019/06/13/2019-6-13-STN_CTC/"/>
    <url>/blog/2019/06/13/2019-6-13-STN_CTC/</url>
    
    <content type="html"><![CDATA[<p>STN（spatial transformer network， 空间变换网络）目的在于增强CNN的旋转不变性以及对于仿射变换的鲁棒性。最终让网络模型学习了对平移、尺度变换、旋转和更多常见的扭曲的不变性。<br><img src="../assets/post/stn.jpg" alt=""></p><p>ST的结构如上图所示,每一个ST模块由Localisation net, Grid generator和Sample组成, Localisation net决定输入所需变换的参数 $θ$, Grid generator通过$θ$和定义的变换方式寻找输出与输入特征的映射$T(θ)$, Sample结合位置映射和变换参数对输入特征进行选择并结合双线性插值进行输出,下面对于每一个组成部分进行具体介绍。</p><h2 id="Localisation-net"><a href="#Localisation-net" class="headerlink" title="Localisation net"></a>Localisation net</h2><p>Localisation net输入为一张Feature map: $U\in R^{H\times W\times C}$ 。经过若干卷积或全链接操作后接一个<strong>回归层</strong>回归输出变换参数$θ$。$θ$的维度取决于网络选择的具体变换类型,如选择仿射变换则 $\theta\in R^{2\times 3}$ 。如选择投影变换则 $\theta\in R^{3\times 3}$ 。$θ$的值决定了网络选择的空间变换的<strong>幅度大小</strong>。</p><h2 id="Grid-generator"><a href="#Grid-generator" class="headerlink" title="Grid generator"></a>Grid generator</h2><p>Grid generator利用localisation层输出的$θ$, 对于Feature map进行相应的空间变换。设输入Feature map U每个像素位置的坐标为$( x<em>{i}^{s} , y</em>{i}^{s} )$,经过ST后输出Feature map每个像素位置的坐标为$( x<em>{i}^{t}，y</em>{i}^{t} )$, 那么输入和输出Feature map的映射关系便为(选择变换方式为仿射变换)</p><script type="math/tex; mode=display">\left(\begin{array}{c}{x_{i}^{s}} \\ {y_{i}^{s}}\end{array}\right)=\tau_{\theta}\left(G_{i}\right)=A_{\theta}\left(\begin{array}{c}{x_{i}^{t}} \\ {y_{i}^{t}} \\ {1}\end{array}\right)=\left[\begin{array}{ccc}{\theta_{11}} & {\theta_{12}} & {\theta_{13}} \\ {\theta_{21}} & {\theta_{22}} & {\theta_{23}}\end{array}\right]\left(\begin{array}{c}{x_{i}^{t}} \\ {y_{i}^{t}} \\ {1}\end{array}\right)</script><p>也就是说,对于输出Feature map的每一个位置,我们对其进行空间变换(仿射变换)寻找其对应与输入Feature map的空间位置,到目前为止,如果这一步的输出为整数值(往往不可能),也就是经过变换后的坐标可以刚好对应原图的某些空间位置,那么ST的任务便完成了,既输入图像在Localisation net和Grid generator后先后的确定了空间变换方式和映射关系。</p><p>但是一些读者看到这可能有一个疑问,这个嵌入的ST网路如何通过反向传播进行参数的训练?没错,如果仅仅包含上述的两个过程,那么ST网络是无法进行反向传播的,原因就是我们上述的操作并不是直接对Feature map进行操作,而是对feature position进行计算,从而寻找输入到输出的对应关系。而feature position对应到feature score是离散的,即feature position进行微小变化时,输出O[x+△x,y]值是无法求解的(图像的计算机存储为离散的矩阵存储)。这里论文作者使用了笔者认为STN最精髓算法,双线性插值算法。</p><p>Sample:<br>经过以上的两步操作后,输出的Feature map上每一个像素点都会通过空间变换对应到输入Feature map的某个像素位置,但是由于feature score对于feature position的偏导数无法计算,因而我们需要构造一种position-&gt;score的映射,且该映射具有可导的性质,从而满足反向传播的条件。即每一个输出的位置i,都有:</p><p>其中 U_{nm} 为输入位置(n,m)对应的score值,k为某种可导函数, Φ为可导函数参数,通过如上的构造方式,我们便可以实现对于 \frac{\partial U}{\partial Xis^{’}} ， \frac{\partial U}{\partial \theta} 等网络参数的求导,从而满足反向传播的要求。如</p><p>论文使用的双线性插值法公式如下:</p><p>我们可以看到,通过max函数选择与输出(x<em>{i}^{s} ,y</em>{i}^{s} )距离小于1的像素位置,距离(x<em>{i}^{s} ,y</em>{i}^{s})越近的点被分配了越高的权重,实现了使用(x<em>{i}^{s} ,y</em>{i}^{s})周围四个点的score计算最终score,由于max函数可导,我们可以有如下偏导数计算公式:</p><p>对于y<em>{i}^{s}的求导与x</em>{i}^{s}类似,因而我们可以求得对于的偏导:</p><p>到目前为止,我们证明了ST模块可以通过反向传播完成对于网络梯度的计算与参数的更新。</p><p>算法分析(STN)</p><p>(1) STN作为一种独立的模块可以在不同网络结构的任意节点插入任意个数并具有运算速度快的特点,它几乎没有增加原网络的运算负担,甚至在一些attentive model中实现了一定程度上的加速。<br>(2) STN模块同样使得网络在训练过程中学习到如何通过空间变换来减少损失函数,使得模型的损失函数有着可观的减少。<br>(3) STN模块决定如何进行空间变换的因素包含在Localisation net以及之前的所有网络层中。<br>(4) 网络除了可以利用STN输出的Feature map外,同样可以将变换参数作为后面网络的输入,由于其中包含着变换的方式和尺度,因而可以从中得到原本特征的某些姿势或角度信息等。<br>(5) 同一个网络结构中,不同的网络位置均可以插入STN模块,从而实现对与不同feature map的空间变换。<br>(6) 同一个网络层中也可以插入多个STN来对于多个物体进行不同的空间变换,但这同样也是STN的一个问题:由于STN中包含crop的功能,所以往往同一个STN模块仅用于检测单个物体并会对其他信息进行剔除。同一个网络层中的STN模块个数在一定程度上影响了网络可以处理的最大物体数量。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++的构造函数以及拷贝构造函数</title>
    <link href="/blog/2019/04/26/2019-04-26-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/blog/2019/04/26/2019-04-26-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>如显示不正常点击查看<a href="https://github.com/Wanger-SJTU/Wanger-SJTU.github.io/blob/master/_posts/2019-04-26-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.md">markdown</a></p><h2 id="调用拷贝构造函数的几种情况"><a href="#调用拷贝构造函数的几种情况" class="headerlink" title="调用拷贝构造函数的几种情况"></a>调用拷贝构造函数的几种情况</h2><blockquote><p>当类中成员有<strong>指针变量</strong>、类中有<strong>动态内存分配</strong>时常常需要用户自己定义拷贝构造函数。</p></blockquote><p>在什么情况下系统会调用拷贝构造函数：</p><blockquote><p>（1）用类的一个对象去初始化另一个对象时<br>（2）当函数的形参是类的对象时（也就是<strong>值传递</strong>时），如果是引用传递则不会调用<br>（3）当函数的<strong>返回值是类的对象或引用</strong>时</p></blockquote><p>代码示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> i):<span class="hljs-built_in">a</span>(i)<br>&#123;<br>cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br>cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">const</span> Test &amp;b)<br>&#123;<br>a = b.a;<br>cout &lt;&lt; b.a &lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span>&lt;&lt; <span class="hljs-string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Test <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Test <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-built_in">Add</span>(a, b);<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="调用函数为值传递"><a href="#调用函数为值传递" class="headerlink" title="调用函数为值传递"></a>调用函数为值传递</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Test <span class="hljs-title">Add</span><span class="hljs-params">(Test a, Test b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">Test</span>(a.a + b.a);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为</p><div class="table-container"><table><thead><tr><th>输出</th><th>解释</th></tr></thead><tbody><tr><td>10      构造函数</td><td></td></tr><tr><td>20      构造函数</td><td>a,b初始化</td></tr><tr><td>20      拷贝构造函数</td><td></td></tr><tr><td>10      拷贝构造函数</td><td>形参的拷贝构造，右到左</td></tr><tr><td>30      构造函数</td><td>Test(a.a + b.a)临时对象</td></tr><tr><td>30      拷贝构造函数</td><td>赋值给res</td></tr><tr><td>30      析构函数</td><td>Test(a.a + b.a)临时对象析构</td></tr><tr><td>10      析构函数</td><td></td></tr><tr><td>20      析构函数</td><td>形参析构</td></tr><tr><td>30      析构函数</td><td>返回值res的析构函数</td></tr><tr><td>20      析构函数</td><td></td></tr><tr><td>10      析构函数</td><td>a,b析构函数</td></tr></tbody></table></div><h4 id="参数为引用传递"><a href="#参数为引用传递" class="headerlink" title="参数为引用传递"></a>参数为引用传递</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Test <span class="hljs-title">Add</span><span class="hljs-params">(Test&amp; a, Test&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">Test</span>(a.a + b.a);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>输出</th><th>解释</th></tr></thead><tbody><tr><td>10      构造函数</td><td></td></tr><tr><td>20      构造函数</td><td>a,b 初始化</td></tr><tr><td>30      构造函数</td><td>Test(a.a + b.a)临时变量初始化</td></tr><tr><td>30      拷贝构造函数</td><td>res的复制构造（值传递）</td></tr><tr><td>30      析构函数</td><td>临时对象析构</td></tr><tr><td>30      析构函数</td><td>res析构</td></tr><tr><td>20      析构函数</td><td></td></tr><tr><td>10      析构函数</td><td>a,b析构</td></tr></tbody></table></div><h4 id="返回值为引用"><a href="#返回值为引用" class="headerlink" title="返回值为引用"></a>返回值为引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Test&amp; <span class="hljs-title">Add</span><span class="hljs-params">(Test&amp; a, Test&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">Test</span>(a.a + b.a);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>输出</th><th>解释</th></tr></thead><tbody><tr><td>10      构造函数</td><td></td></tr><tr><td>20      构造函数</td><td></td></tr><tr><td>30      构造函数</td><td>res 是 临时对象的引用，因此不会拷贝构造</td></tr><tr><td>30      析构函数</td><td></td></tr><tr><td>20      析构函数</td><td></td></tr><tr><td>10      析构函数</td><td></td></tr></tbody></table></div>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 初始化列表</title>
    <link href="/blog/2019/04/26/2019-04-26-C++%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
    <url>/blog/2019/04/26/2019-04-26-C++%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>类对象的构造顺序是：<br>1.分配内存，调用构造函数时，隐式／显示的初始化各数据成员；<br>2.进入构造函数后在构造函数中执行一般赋值与计算。</p><h3 id="使用初始化列表有两个原因："><a href="#使用初始化列表有两个原因：" class="headerlink" title="使用初始化列表有两个原因："></a>使用初始化列表有两个原因：</h3><p><strong>原因1.必须这样做：</strong></p><p>《C++ Primer》中提到在以下三种情况下需要使用初始化成员列表： </p><ol><li>需要<strong>初始化的数据成员是对象</strong>的情况(这里包含了<strong>继承</strong>情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)； </li><li>需要初始化<strong>const修饰的类成员</strong>； </li><li>需要初始化<strong>引用成员数据</strong>；</li></ol><blockquote><p>1 的说明：数据成员是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数；</p></blockquote><p><strong>原因2.效率要求这样做：</strong><br>类对象的构造顺序显示，进入构造函数体后，进行的是计算，是对成员变量的赋值操作，显然，赋值和初始化是不同的，这样就体现出了效率差异，如果不用成员初始化列表，那么类对自己的类成员分别进行的是一次隐式的默认构造函数的调用，和一次赋值操作符的调用，如果是类对象，这样做效率就得不到保障。 </p><h4 id="类成员是对象时的运行分析"><a href="#类成员是对象时的运行分析" class="headerlink" title="类成员是对象时的运行分析"></a>类成员是对象时的运行分析</h4><p><strong>不使用初始化列表</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> i;<br><span class="hljs-built_in">Base</span>()<br>&#123;<br>i = <span class="hljs-number">0</span>;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;Base无参构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">Base</span>(<span class="hljs-keyword">int</span> tmp)<br>&#123;<br>i = tmp;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;Base含参构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">Base</span>(<span class="hljs-keyword">const</span> Base &amp;tmp)<br>&#123;<br>i = tmp.i;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;Base拷贝构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br>Base b;<br><br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> i, Base tmp)<br>&#123;<br>a = i;<br>b = tmp;<br>cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;Test 构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br>cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;Test析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">const</span> Test &amp;b)<br>&#123;<br>a = b.a;<br>cout &lt;&lt; b.a &lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span>&lt;&lt; <span class="hljs-string">&quot;Test拷贝构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base b;<br><span class="hljs-function">Test <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">10</span>, b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>输出为</p><blockquote><p>0       Base无参构造函数<br>0       Base拷贝构造函数<br>0       Base无参构造函数<br>10      Test 构造函数<br>10      Test析构函数</p></blockquote><p>如果不使用初始化列表，Test对象初始化时，需要先调用一次无参构造参数，然后赋值运算，如果没有实现，将会报错。</p><p><strong>使用初始化列表</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br>Base b;<br><br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">int</span> i, Base tmp):<span class="hljs-built_in">a</span>(i),<span class="hljs-built_in">b</span>(tmp)<br>&#123;<br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;Test 构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br>cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; <span class="hljs-string">&quot;Test析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-keyword">const</span> Test &amp;b)<br>&#123;<br>a = b.a;<br>cout &lt;&lt; b.a &lt;&lt;<span class="hljs-string">&#x27;\t&#x27;</span>&lt;&lt; <span class="hljs-string">&quot;Test拷贝构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></p><p>输出为</p><blockquote><p>0       Base无参构造函数<br>0       Base拷贝构造函数<br>0       Base拷贝构造函数<br>10      Test 构造函数<br>10      Test析构函数</p></blockquote><p>使用了初始化列表以后，就可以直接调用拷贝构造函数。如果是传入引用，拷贝构造函数的调用就没有了。</p><h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><ol><li>类里面的任何成员变量在定义时是不能初始化的。 </li><li>一般的数据成员可以在构造函数中初始化。 </li><li>const数据成员必须在构造函数的初始化列表中初始化。 </li><li>static要在类的定义外面初始化。 </li><li>数组成员是不能在初始化列表里初始化的。 </li><li>不能给数组指定明显的初始化。 </li></ol><blockquote><p>3和5决定了，类成员中不能定义常量数组。</p></blockquote><p>初始化列表中成员列出的顺序和它们在类中声明的顺序相同.</p><blockquote><p>对一个对象的所有成员来说，它们的析构函数被调用的顺序总是和它们在构造函数里被创建的顺序相反。那么，如果允许上面的情况（即，成员按它们在初始化列表上出现的顺序被初始化）发生，编译器就要为每一个对象跟踪其成员初始化的顺序，以保证它们的析构函数以正确的顺序被调用。这会带来昂贵的开销。所以，为了避免这一开销，同一种类型的所有对象在创建（构造）和摧毁（析构）过程中对成员的处理顺序都是相同的,而不管成员在初始化列表中的顺序如何</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++初始化列表</title>
    <link href="/blog/2019/04/26/2019-4-26-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
    <url>/blog/2019/04/26/2019-4-26-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Struct中的char*与char数组</title>
    <link href="/blog/2019/04/26/2019-4-26-charinstruct/"/>
    <url>/blog/2019/04/26/2019-4-26-charinstruct/</url>
    
    <content type="html"><![CDATA[<p>这个问题是阿里的一个面试题。当时没有很清楚，答得很差，特地实验看一下运行结果。</p><blockquote><p>在结构体中定义了一个<code>char*</code>指针，与定义一个零元素的<code>char</code>数组有什么区别？</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>常用来构成缓冲区。比起指针，用空数组有这样的优势：</p><ul><li>不需要初始化，数组名直接就是所在的偏移；</li><li>不占任何空间，指针需要占用int长度空间，空数组不占任何空间。<blockquote><p>“这个数组不占用任何内存”，意味着这样的结构节省空间；<br>“该数组的内存地址就和它后面的元素地址相同”，意味着无需初始化，数组名就是后面元素的地址，直接就能当指针使用。</p></blockquote></li></ul><p>这样的写法最适合制作动态buffer，因为可以这样分配空间<code>malloc(sizeof(structXXX) + buff_len)</code>; 直接就把buffer的结构体和缓冲区一块分配了。用起来也非常方便，因为现在空数组其实变成了buff_len长度的数组了。这样的好处是：</p><ul><li>一次分配解决问题，省了不少麻烦。为了防止内存泄露，如果是分两次分配(结构体和缓冲区)，那么要是第二次malloc失败了，必须回滚释放第一个分配的结构体。这样带来了编码麻烦。其次，分配了第二个缓冲区以后，如果结构里面用的是指针，还要为这个指针赋值。同样，在free这个buffer的时候，用指针也要两次free。如果用空数组，所有问题一次解决。</li><li>小内存的管理是非常困难的，如果用指针，这个buffer的struct部分就是小内存了，在系统内存在多了势必严重影响内存管理的性能。要是用空数组把struct和实际数据缓冲区一次分配大块问题，就没有这个问题。如此看来，用空数组既简化编码，又解决了小内存碎片问题提高了性能。</li></ul><p>结构体最后使用0或1长度数组的原因：</p><blockquote><p>为了方便的管理内存缓冲区(其实就是分配一段连续的内存，减少内存的碎片化)，如果直接使用指针而不使用数组，那么，在分配内存缓冲区时，就必须分配结构体一次，然后再分配结构体内的指针一次，(而此时分配的内存已经与结构体的内存不连续了，所有要分别管理即申请和释放)而如果使用数组，那么只需要一次就可以全部分配出来，反过来，释放时也是一样，使用数组，一次释放。使用指针，得先释放结构体内的指针，再释放结构体，还不能颠倒顺序</p></blockquote><p>结构体中最后一个成员为[1]长度数组的用法：与长度为[0]数组的用法相同，改写为[1]是出于可移植性的考虑。有些编译器不支持[0]数组，可将其改成[]或[1].</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span>* b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    <span class="hljs-keyword">char</span> b[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>为了说明这个问题，我们定义一下几个结构体作为比较：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> a;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">char</span>* b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">char</span> b[<span class="hljs-number">0</span>];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">char</span> b[<span class="hljs-number">1</span>];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">E</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">char</span> b[<span class="hljs-number">10</span>];<br>&#125;;<br></code></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(B) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(C) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(D) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(E) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>输出占用空间大小为</p><blockquote><p>4 8 4 8 16</p></blockquote><p>可以看到<code>struct A</code>大小为<code>int</code>大小 4字节，<code>struct B</code>由于包含了一个指针，在32位系统中，大小为 4字节，总共8字节。<code>strcut C</code>大小为4字节，明显<code>char[0]</code>没有分配内存。<code>struct D</code>大小由于内存对齐原因得到为8字节。<code>struct E</code>大小同样由于内存对齐原因得到为16字节。</p><p>由此可以看到长度为0的数组没有分配内存。<br>为了更详细的说明内存分配情况，我们查看一下每个的地址.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">A a; B b; C c; D d; E e;<br>cout &lt;&lt; &amp;a.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; endl;<br>cout &lt;&lt; &amp;b.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;b.b - (<span class="hljs-keyword">int</span>)&amp;b.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; &amp;b.b &lt;&lt; endl;<br>cout &lt;&lt; &amp;c.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c.b - (<span class="hljs-keyword">int</span>)&amp;c.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; &amp;c.b &lt;&lt; endl;<br>cout &lt;&lt; &amp;d.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;d.b - (<span class="hljs-keyword">int</span>)&amp;d.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; &amp;d.b &lt;&lt; endl;<br>cout &lt;&lt; &amp;e.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;e.b - (<span class="hljs-keyword">int</span>)&amp;e.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; &amp;e.b &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure></p><p>输出为:</p><blockquote><p>00AFFB4C<br>00AFFB3C        4       00AFFB40<br>00AFFB30        4       00AFFB34<br>00AFFB20        4       00AFFB24<br>00AFFB08        4       00AFFB0C</p></blockquote><p>可以看到每个<code>b</code>都指向了同一位置,<code>int a</code>后面一位的地址.<br>为了更清楚的描述,在中间插入一个<code>char c</code>可以看到有:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">char</span> c;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">char</span> c;<br><span class="hljs-keyword">char</span>* b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">C</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">char</span> c;<br><span class="hljs-keyword">char</span> b[<span class="hljs-number">0</span>];<br>&#125;;<br><br>A a;<br>B b;<br>C c;<br>cout &lt;&lt; &amp;a.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; endl;<br>cout &lt;&lt; &amp;b.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;b.b - (<span class="hljs-keyword">int</span>)&amp;b.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; &amp;b.b &lt;&lt; endl;<br>cout &lt;&lt; &amp;c.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; (<span class="hljs-keyword">int</span>)&amp;c.b - (<span class="hljs-keyword">int</span>)&amp;c.a &lt;&lt; <span class="hljs-string">&#x27;\t&#x27;</span> &lt;&lt; &amp;c.b &lt;&lt; endl;<br></code></pre></td></tr></table></figure><br>输出为:</p><blockquote><p>012FF9E8<br>012FF9D4        8       012FF9DC<br>012FF9C4        5       012FF9C9</p></blockquote><p>很明显可以得到结论,<code>char b[0]</code>不分配内存,但是可以获得结构体的末尾地址.</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>add digits</title>
    <link href="/blog/2019/04/13/2019-04-13-add_digits/"/>
    <url>/blog/2019/04/13/2019-04-13-add_digits/</url>
    
    <content type="html"><![CDATA[<p>Add Digits<br>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p><p>Example:</p><blockquote><p>Input: 38<br>Output: 2 </p></blockquote><p>Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.  Since 2 has only one digit, return it.</p><p><strong>Follow up</strong>:<br>Could you do it without any loop/recursion in O(1) runtime?</p><h2 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addDigits</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        num = <span class="hljs-built_in">str</span>(num)<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(num)&gt;<span class="hljs-number">1</span>:<br>            num = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num)<br>            num = <span class="hljs-built_in">str</span>(num)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(num)<br></code></pre></td></tr></table></figure><h2 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a><code>O(1)</code></h2><p>这个问题在数学成为“树根问题”（Digital root or repeated digital sum）</p><blockquote><p>数根可以计算模运算的<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98">同余</a>，对于非常大的数字的情况下可以节省很多时间。</p><p>当两个整数除以同一个正整数，若得相同余数，则二整数同余。</p></blockquote><p><strong>同余公式</strong></p><script type="math/tex; mode=display">\operatorname{dr}(n)=\left\{\begin{array}{ll}{0} & {\text { if } n=0} \\ {9} & {\text { if } n \neq 0, n \equiv 0(\bmod 9)} \\ {n \bmod 9} & {\text { if } n \neq 0(\bmod 9)}\end{array}\right.</script><p>更简单表示为：</p><script type="math/tex; mode=display">\operatorname{dr}(n)=1+((n-1) \bmod 9)</script><p>这里对9取模的原因在于，是10进制的情况。<br>因为 $10 \equiv 1 \quad(\bmod 9)$， 所以有：$10^{k} \equiv 1^{k} \equiv 1 \quad(\bmod 9)$</p><script type="math/tex; mode=display">\operatorname{dr}(a b c) \equiv a \cdot 10^{2}+b \cdot 10+c \cdot 1 \equiv a \cdot 1+b \cdot 1+c \cdot 1 \equiv a+b+c \quad(\bmod 9)</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addDigits</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + (num - <span class="hljs-number">1</span>) % <span class="hljs-number">9</span> <span class="hljs-keyword">if</span> num !=<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 生成托管方式编译DLL</title>
    <link href="/blog/2019/04/06/2019-04-06-C++%20managed%20dll/"/>
    <url>/blog/2019/04/06/2019-04-06-C++%20managed%20dll/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python packages</title>
    <link href="/blog/2019/04/04/2019-04-04-packages/"/>
    <url>/blog/2019/04/04/2019-04-04-packages/</url>
    
    <content type="html"><![CDATA[<h2 id="cnocr"><a href="#cnocr" class="headerlink" title="cnocr"></a><a href="https://github.com/breezedeus/cnocr">cnocr</a></h2><p>用来做中文OCR的Python 3包，自带了训练好的识别模型。（mxnet）<br>cnocr是用来做中文OCR的Python 3包。cnocr自带了训练好的识别模型，所以安装后即可直接使用。目前使用的识别模型是crnn，识别准确度约为 98.7%。</p><h2 id="C-常用算法实现集锦"><a href="#C-常用算法实现集锦" class="headerlink" title="(C++)常用算法实现集锦"></a><a href="https://github.com/zimpha/algorithmic-library">(C++)常用算法实现集锦</a></h2><p>Collections of some commonly used algorithms.</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法中的Next数组[转载]</title>
    <link href="/blog/2019/04/04/2019-04-04-next_array/"/>
    <url>/blog/2019/04/04/2019-04-04-next_array/</url>
    
    <content type="html"><![CDATA[<p>kmp算法重要的的就是Next数组的计算。在kmp算法中，失配时，向右移动的距离为:</p><blockquote><p>失配字符所在位置 - 失配字符对应的next 值<br>即：<code>j - next[j]</code>，且此值大于等于1</p></blockquote><p>如下图所示：<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/1.jpg" alt="image"><br>在D失配时，$j=6， Next[j]=2， pos = 6-2=4$。<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/2.jpg?raw=true" alt="image"></p><h2 id="求Next数组"><a href="#求Next数组" class="headerlink" title="求Next数组"></a>求Next数组</h2><ol><li>寻找前缀后缀最长公共元素长度<br>对于$P = [p<em>0,p_1,…,p</em>{j-1},p<em>j]$，寻找模式串$P$中长度最大且相等的前缀和后缀。如果存在$p_0,p_1,…,p</em>{k-1},p<em>k = p</em>{j-k} p<em>{j-k+1},…p</em>{j-1}, p_j$，那么在包含$p_j$的模式串中有最大长度为$k+1$的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：<blockquote><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/3.jpg?raw=true" alt="image"><br>比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k + 1 = 2）。</p></blockquote></li><li>求next数组<br>next 数组考虑的是当前字符之前的字符串前后缀的相似度，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示：<blockquote><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/4.jpg?raw=true" alt="image"><br>比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）。</p></blockquote></li></ol><h3 id="寻找最长前缀后缀"><a href="#寻找最长前缀后缀" class="headerlink" title="寻找最长前缀后缀"></a>寻找最长前缀后缀</h3><p>如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/5.jpg?raw=true" alt="image"><br>也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）：<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/6.jpg?raw=true" alt="image"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partial_table</span>(<span class="hljs-params">p</span>):</span><br>    prefix = <span class="hljs-built_in">set</span>()<br>    postfix = <span class="hljs-built_in">set</span>()<br>    ret = [<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(p)):<br>        prefix.add(p[:i])<br>        postfix = &#123;p[j:i + <span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>)&#125;<br>        ret.append(<span class="hljs-built_in">len</span>((prefix &amp; postfix <span class="hljs-keyword">or</span> &#123;<span class="hljs-string">&#x27;&#x27;</span>&#125;).pop()))<br>    <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure></p><h3 id="基于《最大长度表》匹配"><a href="#基于《最大长度表》匹配" class="headerlink" title="基于《最大长度表》匹配"></a>基于《最大长度表》匹配</h3><blockquote><p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p></blockquote><p><strong>根据《最大长度表》求next 数组</strong></p><blockquote><p>next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1</p></blockquote><p>对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/7.jpg?raw=true" alt="image"></p><p>根据最大长度表求出了next 数组后，从而有 </p><blockquote><p>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</p></blockquote><h3 id="通过代码递推计算next-数组（KMP算法的核心部分）"><a href="#通过代码递推计算next-数组（KMP算法的核心部分）" class="headerlink" title="通过代码递推计算next 数组（KMP算法的核心部分）"></a>通过代码递推计算next 数组（KMP算法的核心部分）</h3><ol><li><p>如果对于值<code>k</code>，已有 $p<em>0,p_1, …, p</em>{k-1} = p<em>{j-k}, p</em>{j-k+1}, …, p_{j-1}$，相当于<code>next[j] = k</code>。</p><ul><li>究其本质，<code>next[j] = k</code> 代表<code>p[j]</code> 之前的模式串子串中，有长度为<code>k</code> 的相同前缀和后缀。有了这个<code>next</code> 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用<code>next[j]</code>处的字符继续跟文本串匹配，相当于模式串向右移动<code>j - next[j]</code> 位。</li></ul></li><li><p>已知next [0, …, j]，如何求出next [j + 1]呢？<br>对于<code>P</code>的前<code>j+1</code>个序列字符：</p><ul><li>若<code>p[k] == p[j]</code>，则<code>next[j+1] = next[j]+1 = k+1</code>；</li><li>若<code>p[k] ≠ p[j]</code>，如果此时<code>p[next[k]] == p[j]</code>，则<code>next[j+1] = next[k]+1</code>，否则继续递归前缀索引<code>k = next[k]</code>，而后重复此过程。（重复找最大的重复前缀后缀）</li></ul></li></ol><p>拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj失配，下一步就是用<code>p[next[k]]</code> 去跟pj 继续匹配，如果<code>p[next[k]]</code>跟pj还是不匹配，则需要寻找<strong>长度更短</strong>的相同前缀后缀，即下一步用<code>p[next[next[k]]]</code>去跟pj匹配。<br>此过程相当于模式串的自我匹配，所以不断的递归<code>k = next[k]</code>，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示：</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/8.jpg?raw=true" alt="image"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNext</span>(<span class="hljs-params">s</span>):</span><br>    Next = [-<span class="hljs-number">1</span>]<br>    j, k = <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(s):<br>        <span class="hljs-keyword">if</span> k == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> s[j] == s[k]:<br>            j+=<span class="hljs-number">1</span><br>            k+=<span class="hljs-number">1</span><br>            Next.append(k)<br>        <span class="hljs-keyword">else</span>:<br>            k = Next[k]<br>    <span class="hljs-keyword">return</span> Next<br></code></pre></td></tr></table></figure></p><h3 id="Next-数组与有限状态自动机"><a href="#Next-数组与有限状态自动机" class="headerlink" title="Next 数组与有限状态自动机"></a>Next 数组与有限状态自动机</h3><p>next 负责把模式串向前移动，且当第j位不匹配的时候，用第<code>next[j]</code>位和主串匹配，就像打了张“表”。此外，next 也可以看作有限状态自动机的状态，在已经读了多少字符的情况下，失配后，前面读的若干个字符是有用的。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/9.jpg?raw=true" alt="image"></p><h3 id="Next-数组的优化"><a href="#Next-数组的优化" class="headerlink" title="Next 数组的优化"></a>Next 数组的优化</h3><p> 如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为<code>-1 0 0 1</code>（<code>0 0 1 2</code>整体右移一位，初值赋为<code>-1</code>），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移<code>j - next[j] = 3 - 1 =2</code>位。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/10.jpg?raw=true" alt="image"></p><p>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知<code>p[3] = b</code>，与<code>s[3] = c</code>失配，而右移两位之后，让<code>p[next[3]] = p[1] = b</code> 再跟<code>s[3]</code>匹配时，必然失配。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/kmp_Next/11.jpg?raw=true" alt="image"></p><p>问题出在不该出现<code>p[j] = p[next[j]]</code>。<br>理由是：当<code>p[j] != s[i]</code> 时，下次匹配必然是<code>p[next[j]]</code> 跟<code>s[i]</code>匹配，如果<code>p[j] = p[next[j]]</code>，必然导致后一步匹配失败（因为<code>p[j]</code>已经跟<code>s[i]</code>失配，然后你还用跟<code>p[j]</code>等同的值<code>p[next[j]]</code>去跟<code>s[i]</code>匹配，很显然，必然失配），所以不能允许<code>p[j] = p[next[j]]</code>。<br>如果出现了<code>p[j] = p[next[j]]</code>咋办呢？</p><blockquote><p>如果出现了，则需要再次递归，即令<code>next[j] = next[next[j]]</code>。<br>总结即是：<br>如果a位字符与它的next值(即next[a])指向的b位字符相等（即p[a] == p[next[a]]）,则a位的next值就指向b位的next值即（next[next[a]]）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNextOptimize</span>(<span class="hljs-params">s</span>):</span><br>    Next = [-<span class="hljs-number">1</span>]<br>    j, k = <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(s):<br>        <span class="hljs-keyword">if</span> k == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> s[j] == s[k]:<br>            j+=<span class="hljs-number">1</span><br>            k+=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>  s[j] == s[k]:<br>                Next.append(Next[k])<br>            <span class="hljs-keyword">else</span>:<br>                Next.append(k)<br>        <span class="hljs-keyword">else</span>:<br>            k = Next[k]<br>    <span class="hljs-keyword">return</span> Next<br></code></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。</p><hr><ul><li><a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长公共子子序列</title>
    <link href="/blog/2019/04/03/2019-04-03-LCS/"/>
    <url>/blog/2019/04/03/2019-04-03-LCS/</url>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong></p><blockquote><p>如果字符串一的所有字符按其在字符串中的顺序出现在另外一个字符串二中，则字符串一称之为字符串二的子串。<br>注意，并不要求子串（字符串一）的字符必须连续出现在字符串二中。</p></blockquote><p>请编写一个函数，输入两个字符串，求它们的最长公共子序列</p><blockquote><p>例如：输入两个字符串BDCABA和ABCBDAB，字符串BCBA和BDAB都是是它们的最长公共子序列，则输出它们的长度4，并打印任意一个子序列。</p></blockquote><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/lcs/1.jpg" alt="image"></p><h2 id="LCS问题具有最优子结构"><a href="#LCS问题具有最优子结构" class="headerlink" title="LCS问题具有最优子结构"></a>LCS问题具有最优子结构</h2><p>令 $X=<x_1,x_2,...,x_m>$ 和 $Y=<y_1,y_2,...,y_n>$ 为两个序列，$Z=<z_1,z_2,z_3,...,z_k>$为$X$和$Y$的任意LCS。则:</p><ul><li>如果$x<em>m=y_n$，则$z_k=x_m=y_n$且$Z</em>{k−1}$是$X<em>{m−1}$和$Y</em>{n−1}$的一个LCS。 </li><li>如果$x<em>m≠y_n$，$z_k≠x_m$，意味着$Z$是$X</em>{m−1}$和$Y$的一个LCS。 </li><li>如果$x<em>m≠y_n$，$z_k≠y_n$，意味着$Z$是$X$和$Y</em>{n−1}$的一个LCS。</li></ul><p>从上述的结论可以看出，两个序列的LCS问题包含两个序列的前缀的LCS，因此，LCS问题具有最优子结构性质。<br>在设计递归算法时，不难看出递归算法具有子问题重叠的性质。<br>  <br>设 $C[i,j]$ 表示 $X_i$ 和 $Y_j$ 的最长公共子序列LCS的长度。如果 $i=0$ 或 $j=0$,即一个序列长度为$0$时，那么LCS的长度为$0$。根据LCS问题的最优子结构性质，可得如下公式：</p><script type="math/tex; mode=display">C[i,j]=   \begin{cases} 0， &        当 i=0或j=0\\    C[i-1,j-1]+1，&当i,j>0 且x_i=y_j \\MAX(C[i,j-1],C[i-1,j])&当i,j>0且x_i≠y_j  \end{cases}</script><h2 id="DP-method"><a href="#DP-method" class="headerlink" title="DP method"></a>DP method</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">LCS</span>(<span class="hljs-params">s1, s2</span>):</span><br>    l1 = <span class="hljs-built_in">len</span>(s1)<br>    l2 = <span class="hljs-built_in">len</span>(s2)<br>    dp = [[<span class="hljs-number">0</span>]*(l1+<span class="hljs-number">1</span>)]*(l2+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,l1+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, l2+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> s1[i-<span class="hljs-number">1</span>] == s[j-<span class="hljs-number">1</span>]:<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]) <br>    <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>dynamic programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 虚函数表以及64位，32系统区别</title>
    <link href="/blog/2019/04/03/2019-04-03-C++%20obj/"/>
    <url>/blog/2019/04/03/2019-04-03-C++%20obj/</url>
    
    <content type="html"><![CDATA[<p>首先看一下代码,判断代码的输出是什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br><span class="hljs-built_in">MyClass</span>(<span class="hljs-keyword">int</span> tmp1 = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> tmp2 = <span class="hljs-number">0</span>)<br>&#123;<br>a = tmp1;<br>b = tmp2;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> a; &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getB</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> b; &#125;<br>~<span class="hljs-built_in">MyClass</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyClass obj = <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">int</span>* pint = (<span class="hljs-keyword">int</span>*)&amp;obj;<br>*(pint + <span class="hljs-number">0</span>) = <span class="hljs-number">100</span>;<br>*(pint + <span class="hljs-number">1</span>) = <span class="hljs-number">200</span>;<br><br>cout &lt;&lt; obj.<span class="hljs-built_in">getA</span>() &lt;&lt; endl;<br>cout &lt;&lt; obj.<span class="hljs-built_in">getB</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为</p><blockquote><p>100,200</p></blockquote><p>使用VS编译可以看到内存布局：<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/C%2B%2B-obj/1.jpg" alt="image"></p><p><code>pint</code>此时指向的位置即为<code>obj.a</code>的地址，<code>pint+1</code>此时指向的位置即为<code>obj.b</code>的地址。赋值以后，输出即为<code>100，200</code>。</p><p>C++中内存对象变量的布局与结构体的布局基本一致，内存对齐方式也一样。唯一不同的是，针对虚函数的实现，在类的内存中有一个虚函数表。</p><p>下面看有虚函数时候的结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> a;<br><span class="hljs-keyword">int</span> b;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br><span class="hljs-built_in">MyClass</span>(<span class="hljs-keyword">int</span> tmp1 = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> tmp2 = <span class="hljs-number">0</span>)<br>&#123;<br>a = tmp1;<br>b = tmp2;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> a; &#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getB</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> b; &#125;<br>~<span class="hljs-built_in">MyClass</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyClass obj = <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">int</span>* pint = (<span class="hljs-keyword">int</span>*)&amp;obj;<br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pint) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) &lt;&lt; endl;<br>*(pint + <span class="hljs-number">0</span>) = <span class="hljs-number">100</span>;<br>*(pint + <span class="hljs-number">1</span>) = <span class="hljs-number">200</span>;<br><br>cout &lt;&lt; obj.<span class="hljs-built_in">getA</span>() &lt;&lt; endl;<br>cout &lt;&lt; obj.<span class="hljs-built_in">getB</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>首先看一下，内存布局：<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/C%2B%2B-obj/2.jpg" alt="image"></p><p>使用VS编译（cl.exe）的时候， 在对象头部添加了一个名字为<code>__vfptr</code>的指针。这个指针指向的位置就是虚函数表，可以看到这里虚函数表，就包含了我们定义的虚函数<code>func()</code>。<br>因此，此时的<code>pint</code>指向的位置就是<code>__vfptr</code>，而不是<code>obj.a</code>.</p><p>当有虚函数的时候，结果就取决于程序是32位还是64位的了。<br>在<strong>32位系统</strong>中，指针长度是4字节与int的长度一致。<code>pint+0</code> 指向的是<code>__vfptr</code>, <code>pint+1</code> 指向的是<code>obj.a</code>。此时结果为</p><blockquote><p>100, 10</p></blockquote><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/C%2B%2B-obj/3.jpg" alt="image"></p><p>在<strong>64位系统</strong>中，指针长度是4字节与int的长度一致。<code>pint+0</code> 指向的是<code>__vfptr</code>, <code>pint+1</code> 指向的是<code>__vfptr的后半部分</code>。此时结果为</p><blockquote><p>5, 10</p></blockquote><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/C%2B%2B-obj/4.jpg" alt="image"></p><blockquote><p>（注：指针+1实际地址走过的字节数取决于指针类型, char<em> 就是2字节， int</em> 就是4字节）</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>虚函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>container with most water</title>
    <link href="/blog/2019/04/02/2019-04-02-container-with-most-water/"/>
    <url>/blog/2019/04/02/2019-04-02-container-with-most-water/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给定一组非负整数，$[a_1,a_2,…,a_n]$, 其中$[i,a_i]$代表了一个坐标。位置$i$处，有高为$a_i$的柱子。 两根柱子连同x轴，构成了一个水池，求可以盛最大体积水的容器坐标。<br> <strong>注</strong>:柱子不可倾斜，n至少为2</p></blockquote><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="image"></p><blockquote><p>TODO 解释</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxArea</span>(<span class="hljs-params">self, height: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        start,end, area = <span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(height)-<span class="hljs-number">1</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> start &lt; end:<br>            new_area = <span class="hljs-built_in">max</span>(area, <span class="hljs-built_in">min</span>(height[start], height[end])*(end-start))<br>            <span class="hljs-keyword">if</span> new_area &gt; area:<br>                area = new_area<br>            <span class="hljs-keyword">if</span> height[start]&gt;height[end]:<br>                end -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                start += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> area<br>        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baidu 4月2号笔试</title>
    <link href="/blog/2019/04/02/2019-04-02-baidu0402/"/>
    <url>/blog/2019/04/02/2019-04-02-baidu0402/</url>
    
    <content type="html"><![CDATA[<ol><li><blockquote><p>描述<br>给定一个仅由小写字母组成的长度不超过1e6的字符串，将首字母移动到末尾并记录所得的字符串，不断重复操作，虽然记录了无限个字符串，但其中不同的字符串数目是有限的，问不同的字符串有多少个？</p></blockquote></li></ol><blockquote><p>输入：<br>abab<br>输出<br>2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNext</span>(<span class="hljs-params">s</span>):</span><br>    Next = [-<span class="hljs-number">1</span>]<br>    j, k = <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(s):<br>        <span class="hljs-keyword">if</span> k == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> s[j] == s[k]:<br>            j+=<span class="hljs-number">1</span><br>            k+=<span class="hljs-number">1</span><br>            Next.append(k)<br>        <span class="hljs-keyword">else</span>:<br>            k = Next[k]<br>    <span class="hljs-keyword">return</span> Next<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    s = <span class="hljs-string">&quot;ababc&quot;</span><br>    Next = getNext(s)<br>    ans = <span class="hljs-built_in">len</span>(s) - Next[<span class="hljs-built_in">len</span>(s)]<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(s) % ans == <span class="hljs-number">0</span>):<br>        <span class="hljs-built_in">print</span>(ans)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(s))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><ol><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pdb<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kmp_match</span>(<span class="hljs-params">s, p</span>):</span><br>    m = <span class="hljs-built_in">len</span>(s);<br>    n = <span class="hljs-built_in">len</span>(p)<br>    cur = <span class="hljs-number">0</span>  <span class="hljs-comment"># 起始指针cur</span><br>    table = partial_table(p)<br>    <span class="hljs-keyword">while</span> cur &lt;= m - n:     <span class="hljs-comment">#只去匹配前m-n个</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> s[i + cur] != p[i]:<br>                cur += <span class="hljs-built_in">max</span>(i - table[i - <span class="hljs-number">1</span>], <span class="hljs-number">1</span>)  <span class="hljs-comment"># 有了部分匹配表,我们不只是单纯的1位1位往右移,可以一次移动多位</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:           <span class="hljs-comment">#for 循环中，如果没有从任何一个 break 中退出，则会执行和 for 对应的 else</span><br>                        <span class="hljs-comment">#只要从 break 中退出了，则 else 部分不执行。</span><br>            <span class="hljs-keyword">return</span> cur<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment"># 部分匹配表</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partial_table</span>(<span class="hljs-params">p</span>):</span><br>    prefix = <span class="hljs-built_in">set</span>()<br>    postfix = <span class="hljs-built_in">set</span>()<br>    ret = [<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(p)):<br>        prefix.add(p[:i])<br>        postfix = &#123;p[j:i + <span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>)&#125;<br>        ret.append(<span class="hljs-built_in">len</span>((prefix &amp; postfix <span class="hljs-keyword">or</span> &#123;<span class="hljs-string">&#x27;&#x27;</span>&#125;).pop()))<br>    <span class="hljs-keyword">return</span> ret<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kmp</span>(<span class="hljs-params">src, pattern</span>):</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(src) &gt; <span class="hljs-built_in">len</span>(pattern):<br>        res = kmp_match(src, pattern)<br>        <span class="hljs-keyword">if</span> res <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> count<br>        <span class="hljs-keyword">else</span>:<br>            src = src[res+<span class="hljs-built_in">len</span>(pattern)-<span class="hljs-number">1</span>:]<br>            count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> count<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    line1 = sys.stdin.readline().strip()<br>    pattern = sys.stdin.readline().strip()<br>    num = <span class="hljs-built_in">int</span>(sys.stdin.readline().strip())<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>        line = sys.stdin.readline().strip().split(<span class="hljs-string">&#x27; &#x27;</span>)<br>        l,r = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, line))<br>        <span class="hljs-built_in">print</span>(kmp(src[l:r+<span class="hljs-number">1</span>], pattern))<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Longest Common Prefix</title>
    <link href="/blog/2019/04/02/2019-04-02-max_prefix/"/>
    <url>/blog/2019/04/02/2019-04-02-max_prefix/</url>
    
    <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1:</p><blockquote><p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:</p><p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonPrefix</span>(<span class="hljs-params">self, strs: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> strs:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        res = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> chars <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*strs):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(chars)) ==<span class="hljs-number">1</span>:<br>                res += chars[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Integer to Roman</title>
    <link href="/blog/2019/04/02/2019-04-02-Integer%20to%20Roman/"/>
    <url>/blog/2019/04/02/2019-04-02-Integer%20to%20Roman/</url>
    
    <content type="html"><![CDATA[<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><div class="table-container"><table><thead><tr><th>字符</th><th>I</th><th>V</th><th>X</th><th>L</th><th>C</th><th>D</th><th>M</th></tr></thead><tbody><tr><td>数值</td><td>1</td><td>5</td><td>10</td><td>50</td><td>100</td><td>500</td><td>1000</td></tr></tbody></table></div><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II。</p><p>通常情况下，罗马数字中<strong>小的数字在大的数字的右边</strong>。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intToRoman</span>(<span class="hljs-params">self, num: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        fives = [<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>]<br>        ones = [<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>]<br>        roman = <span class="hljs-string">&#x27;&#x27;</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> num != <span class="hljs-number">0</span>:<br>            num, n = <span class="hljs-built_in">divmod</span>(num, <span class="hljs-number">10</span>)<br>            current = <span class="hljs-string">&#x27;&#x27;</span><br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">9</span>:<br>                current += ones[i] + ones[i+<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">elif</span> n == <span class="hljs-number">4</span>:<br>                current += ones[i] + fives[i]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">5</span>:<br>                    n = n - <span class="hljs-number">5</span><br>                    current += fives[i]<br>                current += ones[i] * n<br>            roman = current + roman<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> roman<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Roman to Integer</title>
    <link href="/blog/2019/04/02/2019-04-02-Roman%20to%20Integer/"/>
    <url>/blog/2019/04/02/2019-04-02-Roman%20to%20Integer/</url>
    
    <content type="html"><![CDATA[<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><div class="table-container"><table><thead><tr><th>字符</th><th>I</th><th>V</th><th>X</th><th>L</th><th>C</th><th>D</th><th>M</th></tr></thead><tbody><tr><td>数值</td><td>1</td><td>5</td><td>10</td><td>50</td><td>100</td><td>500</td><td>1000</td></tr></tbody></table></div><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II。</p><p>通常情况下，罗马数字中<strong>小的数字在大的数字的右边</strong>。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">romanToInt</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        map_dict = &#123;<span class="hljs-string">&#x27;M&#x27;</span>:<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;D&#x27;</span>:<span class="hljs-number">500</span>, <span class="hljs-string">&#x27;C&#x27;</span>:<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;CD&#x27;</span>:<span class="hljs-number">400</span>, <span class="hljs-string">&#x27;CM&#x27;</span>:<span class="hljs-number">900</span>,<br>                    <span class="hljs-string">&#x27;L&#x27;</span>:<span class="hljs-number">50</span>, <span class="hljs-string">&#x27;XL&#x27;</span>:<span class="hljs-number">40</span>, <span class="hljs-string">&#x27;XC&#x27;</span>:<span class="hljs-number">90</span>, <span class="hljs-string">&#x27;X&#x27;</span>:<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;V&#x27;</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;IV&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;IX&#x27;</span>:<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;I&#x27;</span>:<span class="hljs-number">1</span>&#125;<br>        attend = ([<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>])<br>        idx = <span class="hljs-number">0</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> idx &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[idx] <span class="hljs-keyword">in</span> attend:<br>                <span class="hljs-keyword">if</span> s[idx:idx+<span class="hljs-number">2</span>] <span class="hljs-keyword">in</span> map_dict:<br>                    res += map_dict[s[idx:idx+<span class="hljs-number">2</span>]]<br>                    idx += <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    res += map_dict[s[idx:idx+<span class="hljs-number">1</span>]]<br>                    idx += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                res += map_dict[s[idx:idx+<span class="hljs-number">1</span>]]<br>                idx += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂python装饰器</title>
    <link href="/blog/2019/03/25/2019-03-25-pythondecorator/"/>
    <url>/blog/2019/03/25/2019-03-25-pythondecorator/</url>
    
    <content type="html"><![CDATA[<p>原文地址来自：<a href="https://pouannes.github.io/blog/decorators/">Finally understanding decorators in Python</a></p><p>python 装饰器语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dec</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span><br>  <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><strong>要想理解什么是装饰器，首先要明白装饰器解决了什么问题。</strong></p><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>首先举一个例子，来模拟装饰器要解决的问题。文件<code>dec.py</code>中有一个<code>add</code> 函数，第二个参数为默认参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dec.py</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y=<span class="hljs-number">10</span></span>):</span><br>  <span class="hljs-keyword">return</span> x + y<br></code></pre></td></tr></table></figure><p>调用函数的结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><span class="hljs-number">30</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>add<br>&lt;function add at <span class="hljs-number">0x7fce0da2fe18</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>add.__name__<br><span class="hljs-string">&#x27;add&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>add.__module__<br><span class="hljs-string">&#x27;__main__&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>add.__defaults__ <span class="hljs-comment"># default value of the `add` function</span><br>(<span class="hljs-number">10</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>add.__code__.co_varnames <span class="hljs-comment"># the variable names of the `add` function</span><br>(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>翻译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Not All Pixels Are Equal Difﬁculty-Aware Semantic Segmentation via Deep Layer Cascade</title>
    <link href="/blog/2019/03/25/2019-03-25-notpixeleuqal/"/>
    <url>/blog/2019/03/25/2019-03-25-notpixeleuqal/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Semantic Segmentation</tag>
      
      <tag>Segmentation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PVNet Pixel-wise Voting Network for 6DoF Pose Estimation</title>
    <link href="/blog/2019/03/23/2019-03-23-PVnet/"/>
    <url>/blog/2019/03/23/2019-03-23-PVnet/</url>
    
    <content type="html"><![CDATA[<p>该论文针对的是基于RGB图像与已知模型的6D姿态估计。<br>论文的<code>pipline</code> 是2-stage的，利用CNN进行关键点检测，然后再进行<code>PnP</code>求解。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PVnet/1.jpg" alt="image"></p><h2 id="Voting-based-keypoint-localization"><a href="#Voting-based-keypoint-localization" class="headerlink" title="Voting-based keypoint localization"></a>Voting-based keypoint localization</h2><p>模型结构关键点检测如下图：<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PVnet/2.jpg" alt="image"></p><p>这部分网络主要完成了两部分工作，一个是语义分割，一个矢量估计。这里矢量指的是分割图像中的像素点到关键点的方向。作者提到比起直接回归关键点，这个方法有两个好处：</p><ul><li>模型能够更关注于局部特征，能不被背景影响。</li><li>对于遮挡，以及仅有部分图像的情形也能很好的预测关键点位置。</li></ul><p>对于像素点 $\mathbf{p}$ ， 其到关键点   $\mathbf{x}_k$ 矢量 $\mathbf{v}_k(p)$表示为 </p><script type="math/tex; mode=display">\mathbf{v}_{k}(\mathbf{p})=\frac{\mathbf{x}_{k}-\mathbf{p}}{\left\|\mathbf{x}_{k}-\mathbf{p}\right\|_{2}}</script><p><strong>key-point hypotheses</strong></p><p>key-point关键点的选取是基于RANSAC的投票方法：具体如下：</p><ul><li>根据语义分割结果随机选取两个点，这两个点对应向量的交集 $\mathbf{h}_{k,i}$ 记为 $\mathbf{x}_k$ 的一个潜在选择。</li><li>重复上述步骤N次，得到N个假设。</li><li>根据RANSAC方法投票得到最终的关键点。</li><li><p>其中,每个点的voting score $w_{k,i}$ 定义为：</p><script type="math/tex; mode=display">w_{k, i}=\sum_{\mathbf{p} \in O} \mathbb{I}\left(\frac{\left(\mathbf{h}_{k, i}-\mathbf{p}\right)^{T}}{\left\|\mathbf{h}_{k, i}-\mathbf{p}\right\|_{2}} \mathbf{v}_{k}(\mathbf{p}) \geq \theta\right)</script><p>$\mathbb{I}$ 是指示函数, $\theta$ 是阈值(0.99 in all experiments), and $p \in O$ 目标 $O$ 的所有像素 $p$。</p></li></ul><p>最终的关键点假设表示为空间概率分布的形式：</p><p>其中均值和方差 $\boldsymbol{\mu}<em>{k} \;\text{、}\boldsymbol{\Sigma}</em>{k}$ 分别为：</p><script type="math/tex; mode=display">{\boldsymbol{\mu}_{k}=\frac{\sum_{i=1}^{N} w_{k, i} \mathbf{h}_{k, i}}{\sum_{i=1}^{N} w_{k, i}}}</script><script type="math/tex; mode=display">{\boldsymbol{\Sigma}_{k}=\frac{\sum_{i=1}^{N} w_{k, i}\left(\mathbf{h}_{k, i}-\boldsymbol{\mu}_{k}\right)\left(\mathbf{h}_{k, i}-\boldsymbol{\mu}_{k}\right)^{T}}{\sum_{i=1}^{N} w_{k, i}}}</script><p><strong>注</strong>：这个结果在后面的<code>PnP</code>求解过程中用得到。</p><p><strong>Keypoint selection</strong></p><p>为保证PnP的求解问题，特征点的选择必须分散在物体表面。为此，作者提出使用 farthest point sampling (FPS) algorithm来进行特征点的选择。</p><ul><li>首先把特征点选在目标中心</li><li>然后选取距离上一个点最远点作为下一个特征点，重复直到选取了K个点。 </li></ul><p>实验中，作者对比了实验结果，K=8</p><p><strong>Multiple instances</strong></p><p>对于每类对象，使用提出的投票方案生成对象中心的假设及其投票得分。 然后，在假设中找到模式，并将这些模式标记为不同实例的中心。 最后，通过将像素分配给他们投票的最近的实例中心来获得实例掩码。</p><h2 id="Uncertainty-driven-PnP"><a href="#Uncertainty-driven-PnP" class="headerlink" title="Uncertainty-driven PnP"></a>Uncertainty-driven PnP</h2><script type="math/tex; mode=display">\begin{array}{c}{  \operatorname{minimize} \sum_{k=1}^{K}\left(\tilde{\mathbf{x}}_{k}-\boldsymbol{\mu}_{k}\right)^{T} \mathbf{\Sigma}_{k}^{-1}\left(\tilde{\mathbf{x}}_{k}-\boldsymbol{\mu}_{k}\right)} \\ \\{\tilde{\mathbf{x}}_{k}=\pi\left(R \mathbf{X}_{k}+\mathbf{t}\right)}\end{array}</script><p>$X_k$ 为关键点的3D坐标，$ \tilde{x}_k$ 是$X_k$ 的2D投影, $\pi$ 为投影函数. $ R $ 和 $t$ 的参数根据我们迹最小的4个关键点由 EPnP 取得，最后使用 Levenberg-Marquardt 算法求解上述方程。</p><p>最小化重构误差。</p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>假设有$C$个类，每个类有$K$个关键点。图片大小为$H×W×3$，输出为 $H ×W ×(K ×2×C)$ 的Tensor（预测向量） 与 $H×W ×(C+1)$ 的 Tensor（语义分割）。</p><blockquote><p>We use a pretrained ResNet-18 [16] as the backbone network, and we make three revisions on it. First, when the feature map of the network has the size H/8 × W/8, we do not downsample the feature map anymore by discarding the subsequent pooling layers. Second, to keep the receptive ﬁelds unchanged, the subsequent convolutions are replaced with suitable dilated convolutions [45]. Third, the fully connected layers in the original ResNet-18 are replaced with convolution layers. Then, we repeatedly perform skip connection, convolution and upsampling on the feature map, until its size reaches H × W , as shown in Figure 2(b). By applying a 1 × 1 convolution on the ﬁnal feature map, we obtain the unit vectors and class probabilities</p><p>We implement hypothesis generation, pixel-wise voting and density estimation using CUDA. The EPnP [24] used to initialize the pose is implemented in OpenCV [5]. To obtain the ﬁnal pose, we use the iterative solver Ceres [1] to mini-mize the Mahalanobis distance (5). For symmetric objects, there are ambiguities of keypoint locations. To eliminate the ambiguities, we rotate the symmetric object to a canonical pose during training, as suggested by [33].</p></blockquote><h3 id="Training-strategy"><a href="#Training-strategy" class="headerlink" title="Training strategy"></a>Training strategy</h3><p>训练过程使用的是Fast-rcnn中的<code>l1_loss</code>。</p><script type="math/tex; mode=display">\begin{aligned} \ell(\mathbf{w})&=\sum_{k=1}^{K} \sum_{\mathbf{p} \in O} \ell_{1}\left(\boldsymbol{\Delta} \mathbf{v}_{k}\left.(\mathbf{p} ; \mathbf{w})\right|_{x}\right)+\ell_{1}\left(\boldsymbol{\Delta} \mathbf{v}_{k}\left.(\mathbf{p} ; \mathbf{w})\right|_{y}\right) \\ \boldsymbol{\Delta} \mathbf{v}_{k}(\mathbf{p} ; \mathbf{w}) &=\tilde{\mathbf{v}}_{k}(\mathbf{p} ; \mathbf{w})-\mathbf{v}_{k}(\mathbf{p}) \end{aligned}</script><p>$w$ 为 PVNet 的参数, $\tilde{v}_k$ 为预测的向量, $v_k$ 是其ground truth, $\Delta v_k\vert x $ 和 $\Delta v_k\vert y$ 代表了 $\Delta v_k$的两部分。</p><p>训练语义分割部分时，使用的是交叉熵函数。 </p><p>测试阶段，不再需要将输出的矢量单位化了，因为仅仅需要方向信息。</p><blockquote><p>We set the initial learning rate as 0.001 and halve it every 20 epochs. All models are trained for 200 epochs.</p></blockquote><h2 id="其他的"><a href="#其他的" class="headerlink" title="其他的"></a>其他的</h2><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PVnet/3.jpg" alt="image"></p><p>作者没有采用3D bounding box 作为特征点。是基于点距离模型本身太远，不足以表示模型特征。<br>实验对比可以发现， 作者的方式是方差更小，贴合在表面。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Pose Estimation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pixel Transposed Convolutional Networks</title>
    <link href="/blog/2019/03/20/2019-03-20-PTCN/"/>
    <url>/blog/2019/03/20/2019-03-20-PTCN/</url>
    
    <content type="html"><![CDATA[<p>论文提出我们常用的 转置卷积（transposed convolutional layer）没有考虑到像素之间的关联性，进而会导致了结果的下降。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/1.jpg" alt="compare"></p><p>上图结果对比了使用和不适用Pixel transpose convolutional layer的区别。可以看到作者提出的方法对于像素之间的关联性考虑的更好。</p><h2 id="Convolutional-Layers"><a href="#Convolutional-Layers" class="headerlink" title="Convolutional Layers"></a>Convolutional Layers</h2><p>首先介绍一下卷积操作：</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/2.jpg" alt="image"></p><p>如图所示,对于一个4*4的矩阵，卷积核大小为3*3的时候，输出为矩阵的大小为2*2。<br>更一般的我们有：</p><script type="math/tex; mode=display">N'=\frac{N-k+2p}{stride}+1</script><p>显然卷积操作对应了一个 <code>many-to-one</code> 的映射操作。</p><p>其实在实际计算的时候，卷积操作被重构为矩阵乘法问题。依旧以4*4矩阵，3*3卷积核为例。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/3.jpg" alt="image"></p><p>卷积核可以重塑为</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/4.jpg" alt="image"></p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/5.jpg" alt="image"></p><p>卷积操作可以写成矩阵乘法的问题</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/6.jpg" alt="image"></p><h2 id="Transposed-Convolutional-Layers"><a href="#Transposed-Convolutional-Layers" class="headerlink" title="Transposed Convolutional Layers"></a>Transposed Convolutional Layers</h2><p>继续我们上面的讨论，如果将这个操作反过来，输入矩阵中的一个值映射到输出矩阵的9个值，这将是一个一对多<code>one-to-many</code>的映射关系。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/7.jpg" alt="image"></p><p>那么如何去做？</p><p>在上面提到，卷积操作其实可以转化为 $outputs=inputs\times kernel$的矩阵乘法问题。则显然有 $inputs=kernel^T \times outputs$</p><p>即：</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/8.jpg" alt="image"></p><p>在论文中，作者提出，转置卷积操作可以分解为几个卷积操作然后 Upsampling 操作的集合：</p><script type="math/tex; mode=display">\begin{aligned} F_{1} &=F_{i n} \circledast k_{1} \\ F_{2} &=F_{i n} \circledast k_{2} \\F_{3} &=F_{i n} \circledast k_{3} \\F_{4} &=F_{i n} \circledast k_{4}  \\F_{o u t}&=F_{1} \oplus F_{2} \oplus F_{3} \oplus F_{4}\end{aligned}</script><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/9.jpg" alt="1D"></p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/10.jpg" alt="2D"></p><script type="math/tex; mode=display">\begin{aligned} F_{1} &=F_{i n} \circledast k_{1} \\ F_{2} &=\left[F_{i n}, F_{1}\right] \circledast k_{2} \\ F_{3} &=\left[F_{i n}, F_{1}, F_{2}\right] \circledast k_{3} \\ F_{4} &=\left[F_{i n}, F_{1}, F_{2}, F_{3}\right] \circledast k_{4} \\ F_{o u t} &=F_{1} \oplus F_{2} \oplus F_{3} \oplus F_{4} \end{aligned}</script><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/11.jpg" alt="image"></p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PTCN/12.jpg" alt="image"></p><p><strong>注：</strong></p><ol><li>关于卷积操作介绍来自于：<a href="https://blog.csdn.net/LoseInVain/article/details/81098502">CSDN</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Segmentation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>subset_sum</title>
    <link href="/blog/2019/03/18/2019-03-18-subset_sum/"/>
    <url>/blog/2019/03/18/2019-03-18-subset_sum/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>子集和问题（Subset sum problem），又称子集合加总问题，是计算复杂度理论和密码学中一个很重要的问题。<br>问题可以描述为：</p><blockquote><p>给一个整数集合，问是否存在某个非空子集，使得子集内中的数字和为0。<br>例：给定集合{−7, −3, −2, 5, 8}，答案是YES，因为子集{−3, −2, 5}的数字和是0。</p></blockquote><p>这个问题是NP完全问题，且或许是最容易描述的NP完全问题。</p><p>等价的问题</p><blockquote><p>给一个整数集合L和另一个整数target，问是否存在某个非空子集，使得子集中的数字和为s。<br><em>子集合加总问题可以想成是<strong>背包问题</strong>的一个特例</em>。</p></blockquote><h1 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h1><h2 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h2><blockquote><p>求解集合A 所有的排列组合，一共有2的n次方种可能，然后逐一对组合求和判断是否等于target。<br>这种思路属于暴力求解法，当集合元素非常多的时候，计算时间会指数级增长，该算法的时间复杂度为O(2^n)。</p></blockquote><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>可以使用一个bit vector 表示得到的solution，如果某个元素被选中了，那么在bit vector 对应的索引下记为1，否则，没有选中记为0.接下来可以创建一个二叉树，其中level i 代表权重wi。 每一个节点引出两个branch，一个branch标记为0，一个标记为1. 标记为0的意思是这个branch引出的孩子节点对应的weight不再答案选中，标记为1表示引出的child选中。所以向量（1，0，1）表示从节点开始，选中left branch，然后右边branch，然后再左边的branch。要找到所有可能的答案，就得遍历这棵树，然后只要和为M，就打印出从根节点到这条路径所有的节点即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsetSum</span>(<span class="hljs-params">nums:<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], path:<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>)-&gt; <span class="hljs-built_in">int</span>:</span><br>    res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item,w <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(nums, path):<br>        <span class="hljs-keyword">if</span> w == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> res<br>        res += w*item<br>    <span class="hljs-keyword">return</span> res<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subset</span>(<span class="hljs-params">nums:<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target:<span class="hljs-built_in">int</span></span>)-&gt;<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>    nums = <span class="hljs-built_in">sorted</span>(nums)<br>    path = [-<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>    idx = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> idx &lt; <span class="hljs-built_in">len</span>(nums):<br>        tmp_sum = subsetSum(nums, path)<br>        <span class="hljs-keyword">if</span>  tmp_sum == target:<br>            <span class="hljs-keyword">return</span> path<br>        <span class="hljs-keyword">elif</span> tmp_sum + nums[idx] &lt;= targetSum:<br>            path[idx] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> idx &lt; <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span>  tmp_sum + nums[idx+<span class="hljs-number">1</span>] &lt;= targetSum:<br>            path[idx] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>假设给定数组是有序的，必然有$sum(L[i,j]) == target, L[j] \leq target$<br>递推公式：</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/20106964">更快的subset sum的伪多项式时间算法</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>DP</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Dynamic Planing</tag>
      
      <tag>back tracking</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lru cache 与缓存机制</title>
    <link href="/blog/2019/03/16/2019-03-16-lru%20cache/"/>
    <url>/blog/2019/03/16/2019-03-16-lru%20cache/</url>
    
    <content type="html"><![CDATA[<p>函数缓存是：</p><blockquote><p>第一次调用时，正常执行，并缓存计算结果。<br>使用相同的参数，第二次调用时，不执行，直接加载计算结果。</p></blockquote><p>在 Python 的 3.2 版本中，引入了一个非常优雅的缓存机器，即 <code>functool</code> 模块中的 <code>lru_cache</code> 装饰器</p><blockquote><p>@functools.lru_cache(maxsize=None, typed=False)</p></blockquote><p>使用functools模块的lur_cache装饰器，可以缓存最多 maxsize 个此函数的调用结果，从而提高程序执行的效率，特别适合于耗时的函数。参数maxsize为最多缓存的次数，如果为None，则无限制，设置为2n时，性能最佳；如果 typed=True（注意，在 functools32 中没有此参数），则不同参数类型的调用将分别缓存，例如 f(3) 和 f(3.0)。</p><p>以斐波那契数列计算为例，动态规划的方法是利用两个变量存储<code>f(n-1)</code> 和<code>f(n-2)</code><br>此处可以使用这个函数简化代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<br><br><br><span class="hljs-meta">@lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib4</span>(<span class="hljs-params">n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span>  <span class="hljs-comment"># same definition as fib2()</span><br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:  <span class="hljs-comment"># base case</span><br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">return</span> fib4(n - <span class="hljs-number">2</span>) + fib4(n - <span class="hljs-number">1</span>)  <span class="hljs-comment"># recursive case</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RANSAC 随机采样一致</title>
    <link href="/blog/2019/03/15/2019-03-15-RANSACsample/"/>
    <url>/blog/2019/03/15/2019-03-15-RANSACsample/</url>
    
    <content type="html"><![CDATA[<p>RANSAC 是根据一组包含异常数据的样本数据集，通过迭代的方法计算出数据的数学模型参数，得到有效样本数据的非确定性的算法。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>算法假设</p><blockquote><ul><li>样本中包含正确数据(inliers，符合模型的数据)和异常数据(Outliers，不符合模型的数据)，即数据集中含有噪声。</li><li>给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。</li></ul></blockquote><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/RANSACsample/1.jpg" alt="image"></p><p>给定一组观测数据（往往含有较大的噪声或无效点），一个用于解释观测数据的参数化模型以及一些可信的参数。RANSAC通过反复选择数据中的一组随机子集来达成目标。被选取的子集被假设为局内点，并用下述方法进行验证：</p><ol><li>有一个模型适应于假设的局内点，即所有的未知参数都能从假设的局内点计算得出。</li><li>用1中得到的模型去测试所有的其它数据，如果某个点适用于估计的模型，认为它也是局内点。</li><li>如果有足够多的点被归类为假设的局内点，那么估计的模型就足够合理。</li><li>用所有假设的局内点去重新估计模型（如使用最小二乘法），因为它仅仅被初始的假设局内点估计过。</li><li>通过估计局内点与模型的错误率来评估模型。</li></ol><blockquote><p>在数据中随机选择几个点设定为内群<br>计算拟合内群的模型<br>把其它刚才没选到的点带入刚才建立的模型中，计算是否为内群<br>记下内群数量<br>重复以上步骤多做几次<br>比较哪次计算中内群数量最多，内群最多的那次所建的模型就是我们所要求的解</p></blockquote><p>这里有几个问题</p><ul><li>一开始的时候我们要随机选择多少点（n）</li><li>以及要重复做多少次（k）</li></ul><p><strong>参数决定</strong><br>假设每个点是真正内群的机率是 $w$</p><blockquote><p>$w$ = 真正內群的数目 / 数据总量</p></blockquote><p>通常我们不知道$w$是多少, $w^n$是所选择的$n$个点都是内群的机率, $1-w^n$ 是所选择的 $n$ 个点至少有一个不是内群的机率, $(1 − w^n)^k$ 是表示重复 $k$ 次都没有全部的 $n$ 个点都是内群的机率, 这边定算法跑k次以后成功的机率是 $p$，那么,</p><script type="math/tex; mode=display">   1 − p =(1 − w^n)^k \\   p = 1 −(1 − w^n)^k</script><p>所以如果希望成功机率高，$p = 0.99$, 当$n$不变时，$k$越大,$p$越大, 当$w$不变时，$n$越大，所需的$k$就越大, 通常$w$未知，所以$n$选小一点比较好。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/RANSACsample/2.jpg" alt="image"></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>图片拼接</p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.475.1243&amp;rep=rep1&amp;type=pdf">RANSAC for Dummies</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Marr Revisited 2D-3D Alignment via Surface Normal Prediction</title>
    <link href="/blog/2019/03/14/2019-03-14-2d3D%20alignment/"/>
    <url>/blog/2019/03/14/2019-03-14-2d3D%20alignment/</url>
    
    <content type="html"><![CDATA[<p>论文是15年CVPR。论文提出了一种2D 3D图像匹配对准的方法，首先对RGB图像预测表面法向，然后结合法向信息做CAD模型搜索进而得到模型的 pose 信息。</p><p>效果如下：<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/2d3D-alignment/1.jpg" alt="image"></p><h2 id="Surface-Norm"><a href="#Surface-Norm" class="headerlink" title="Surface Norm"></a>Surface Norm</h2><p>模型结构如下：<br><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/2d3D-alignment/2.jpg" alt="image"></p><p>论文使用VGG-16作为特征提取工具，然后将获得的卷积特征交给后面的全连接层，回归得到法向信息。<br>不同于一般的利用方法，这里使用的是<code>hypercolumn</code>的方法，因为预测的是每一像素点的法向信息，考虑使用使用多层的卷积特征。给定图像 $I$, 位置 $p$ 处的特征定义为 $h_p(I)$, 不同的卷积层输出记为 $C_p^{ji},\quad i = 0\rightarrow \alpha$。 所以有 $h_p(I) = [C_p^{j1}, \cdots, C_p^{j\alpha}]$。 考虑到不同层的特征图大小有所区别，就将其resize 到同样大小（image）。</p><p>后面回归网络，loss 函数为</p><script type="math/tex; mode=display">\min _{\theta} \sum_{i=1}^{N} \sum_{p}\left\|n_{p}\left(I_{i} ; \theta\right)-\hat{n}_{i, p}\right\|^{2}</script><h2 id="Pose-and-Style"><a href="#Pose-and-Style" class="headerlink" title="Pose and Style"></a>Pose and Style</h2><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/2d3D-alignment/3.jpg" alt="image"></p><h3 id="PoseNet"><a href="#PoseNet" class="headerlink" title="PoseNet"></a>PoseNet</h3><p>这部分是对目标的姿态进行估计，在这部分中将姿态估计问题转化为视角分类问题。将视角离散化为36类，然后利用修改过的AlexNet 作为分类网络进行估计。这个网络没有什么好说的，就是两边输入分别为Image和Norms，pool5以后的feature map 合在一起进行分类。<br>该论文使用了 <code>Render CNN</code> 将渲染图与真实场景结合到一起进行训练。而非直接利用渲染图训练。</p><h3 id="StyleNet"><a href="#StyleNet" class="headerlink" title="StyleNet"></a>StyleNet</h3><p>上述网络仅仅分类了Pose的信息，没有用到关于目标本身形状信息。因此提出使用StyleNet分析目标与CAD模型之间的Style关系。<br>该部分使用的仍然是AlexNet，不同的是这里用的是孪生网络。用来判断两个输入对象的匹配程度。为此，手工标注了图像与CAD模型之间的风格匹配关系，将匹配的记作$(p,q)$， 差异比较大的记作$(q,n)$。 优化判别loss</p><script type="math/tex; mode=display">\begin{aligned}L(\Theta)&=\sum_{(q, p)} L_{p}\left(f_{q}, f_{p}\right)+\sum_{(q, n)} L_{n}\left(f_{q}, f_{n}\right)\\L_{p}\left(f_{q}, f_{p}\right)&=\left\|f_{q}-f_{p}\right\|_{2} \\   L_{n}\left(f_{q}, f_{n}\right)&=\max \left(m-\left\|f_{q}-f_{n}\right\|_{2}, 0\right) \quad m=1\end{aligned}</script><h2 id="Retrival"><a href="#Retrival" class="headerlink" title="Retrival"></a>Retrival</h2><p>检索方面，PoseNet和StyleNet都是依靠boundingBox来优化的。</p><h3 id="based-on-Norm"><a href="#based-on-Norm" class="headerlink" title="based on Norm"></a>based on Norm</h3><p>在给定boundingBox里面，变换CAD模型来确定模型旋转角度与大小。</p><p>使用了两种方法评价角度问题：</p><ul><li>计算点积</li><li><blockquote><p>compute the angular error between the two, and then compute the percentage of pixels within 30° angular error (we call this criteria ‘Geom’)</p></blockquote></li></ul><h3 id="based-on-PoseNet-and-StyleNet"><a href="#based-on-PoseNet-and-StyleNet" class="headerlink" title="based on PoseNet and StyleNet"></a>based on PoseNet and StyleNet</h3><p>基于<code>pool5</code>特征的检索。</p><h2 id="关于这篇论文"><a href="#关于这篇论文" class="headerlink" title="关于这篇论文"></a>关于这篇论文</h2><p>这篇论文相对于之前的文章，改动创新不大。实验很充分，检索方面倒是缺少跟不同物体的模型输出。</p><p>启发主要有以下几点：</p><ul><li>关于表面法向对于姿态估计的影响能有多大</li><li>能否有一个End2End框架解决这个问题，（包括分割、法向估计，精确位姿）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Pose Estimation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Training ImageNet 1 hour</title>
    <link href="/blog/2019/03/11/2019-03-11-training%20ImageNet%201%20hour/"/>
    <url>/blog/2019/03/11/2019-03-11-training%20ImageNet%201%20hour/</url>
    
    <content type="html"><![CDATA[<p>论文针对的是神经网络的训练技巧，在训练过程中如何应对大数据。在增大batchsize的同时，其他参数如何设置，才能使得训练模型鲁棒性更好，不至于准确度下降。论文首先给出了，一般情况下增大batch对于准确度的影响，可以看到一定程度以后，准确度是下降的。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/training-ImageNet-1-hour/1.jpg" alt="Figure 1"></p><h2 id="large-batchsize"><a href="#large-batchsize" class="headerlink" title="large batchsize"></a>large batchsize</h2><h3 id="linear-scale"><a href="#linear-scale" class="headerlink" title="linear scale"></a>linear scale</h3><p>论文中使用SGD作为求解器，通常情况下的loss函数可以写成下面的形式。$X$代表了训练数据集，$w$ 表示网络参数， $x\in X $表示了训练数据。</p><script type="math/tex; mode=display">L(w)=\frac{1}{|X|} \sum_{x \in X} l(x, w)</script><p>使用<code>mini-batch</code>以后，参数的更新方式如下：</p><script type="math/tex; mode=display">w_{t+1}=w_{t}-\eta \frac{1}{n} \sum_{x \in \mathcal{B}} \nabla l\left(x, w_{t}\right)</script><p>其中$\mathcal{B}$是一个<code>batch</code>的数据，$n=\vert\mathcal{B}\vert$ , $\eta$ 是<code>lr</code>， $t$ 迭代次数。</p><blockquote><p>When the minibatch size is multiplied by $k$, multiply the learning rate by $k$.</p><p><code>lr</code> 扩大倍数与<code>batchSize</code>的扩大倍数一致</p></blockquote><p><strong>解释</strong>：<br>假设在第$t$次跌打，参数为$w_t$，对照两种方式的更新公式，一种的多次迭代，一种是一次迭代。对于前者，我们假设有$k$次迭代，每次的<code>batch</code> 为$\mathcal{B}_j,\quad 0 \leq j &lt; k ,\; |\mathcal{B}_j|=n$。学习率为$\eta$</p><script type="math/tex; mode=display">w_{t+k}=w_{t}-\eta \frac{1}{n} \sum_{j< k} \sum_{x \in \mathcal{B}_{j}} \nabla l\left(x, w_{t+j}\right)</script><p>后者一次的<code>batch</code>为$\cup_j\mathcal{B}_j, \text{size}=kn​$.学习率为$\hat{\eta}​$</p><script type="math/tex; mode=display">\hat{w}_{t+1}=w_{t}-\hat{\eta} \frac{1}{k n} \sum_{j < k} \sum_{x \in \mathcal{B}_{j}} \nabla l\left(x, w_{t}\right)</script><p>显然有，二者不太可能相等。假设$\nabla l\left(x, w<em>{t}\right) \approx \nabla l\left(x, w</em>{t+j}\right) \text { for } j&lt; k$,   $\hat{\eta}=k \eta$</p><p>但是假设有时候是不成立的，比如在梯度变化比较大的时候，这两个的梯度是相差很大的。因此这就需要<code>warmup phase</code>.</p><h3 id="Warmup"><a href="#Warmup" class="headerlink" title="Warmup"></a>Warmup</h3><p><strong>Constant warmup</strong></p><p>在开始阶段使用 一个比较小的常数 <code>lr</code>， 作者在实验中发现这种方式对于 Fine-tuning, 分割、检测效果不错。具体就是先4-5个epoch，使用较小的<code>lr</code>， 然后增大为 <code>k</code>倍。</p><p><strong>Gradual warmup</strong></p><p>线性增加<code>lr</code>，然后逐步到<code>kn</code></p><h2 id="Batch-Normalization-with-Large-Minibatches"><a href="#Batch-Normalization-with-Large-Minibatches" class="headerlink" title="Batch Normalization with Large Minibatches"></a>Batch Normalization with Large Minibatches</h2><p><code>BatchNorm</code>的统计信息是依赖于<code>batch</code>的大小的。</p><p>记 $l<em>{\mathcal{B}}(x, w)$ 为单个样本数据的<code>loss</code>， $L(\mathcal{B}, w)=\frac{1}{n} \sum</em>{x \in \mathcal{B}} l_{\mathcal{B}}(x, w)$ 为 一个Batch的loss。当包含<code>BN</code>的时候，有</p><script type="math/tex; mode=display">L(w)=\frac{1}{\left|X^{n}\right|} \sum_{\mathcal{B} \in X^{n}} L(\mathcal{B}, w)</script><p>不同batch之间的loss计算是相互独立的，但是由于随着batchSize的改变，统计量的计算也有所不同，那么优化的目标函数也会发生改变。<br>在多GPU训练时，如果每块GPU上的batch大小为<code>n</code>，总的batch为<code>kn</code>，那可以看作将<code>kn</code>大小的batch以<code>n</code>大小的batch <code>forward</code>了k次。</p><script type="math/tex; mode=display">{w_{t+k}=w_{t}-\eta \sum_{j< k} \nabla L\left(\mathcal{B}_{j}, w_{t+j}\right)}</script><script type="math/tex; mode=display">{\hat{w}_{t+1}=w_{t}-\hat{\eta} \frac{1}{k} \sum_{j < k} \nabla L\left(\mathcal{B}_{j}, w_{t}\right)}</script><p>可以看出$\hat{\eta}=k n$时。</p><h3 id="一点补充"><a href="#一点补充" class="headerlink" title="一点补充"></a>一点补充</h3><p>batchNorm的计算其实是用的是滑动平均，还有如果保持运算性质的话，可以使用<code>sync BN</code></p><h2 id="Distributed-SGD-需要注意的点"><a href="#Distributed-SGD-需要注意的点" class="headerlink" title="Distributed SGD 需要注意的点"></a>Distributed SGD 需要注意的点</h2><h3 id="Weight-decay"><a href="#Weight-decay" class="headerlink" title="Weight decay"></a>Weight decay</h3><p>Weight decay 对应着loss里面的<code>L2</code>正则化损失。可以写为 $l(x, w)=\frac{\lambda}{2}|w|^{2}+\varepsilon(x, w)$， $\varepsilon(x, w)$是与样本相关的偏差量<br>此时SGD的公式为，</p><script type="math/tex; mode=display">w_{t+1}=w_{t}-\eta \lambda w_{t}-\eta \frac{1}{n} \sum_{x \in \mathcal{B}} \nabla \varepsilon\left(x, w_{t}\right)</script><p>通常来说，与样本相关的部分$\sum \nabla \varepsilon\left(x, w<em>{t}\right)$才会在反向传播中被计算，$\lambda w</em>{t}$是单独计算然后加到梯度当中的。因此，当没有 weight decay时， linear scale 是可行的，注意对$\varepsilon(x, w)$ 缩放即可。 但是对 ce loss, linear scale 是不可行的。</p><blockquote><p>Remark 1: Scaling the cross-entropy loss is not equivalent to scaling the learning rate.</p></blockquote><h3 id="Momentum-correction"><a href="#Momentum-correction" class="headerlink" title="Momentum correction"></a>Momentum correction</h3><script type="math/tex; mode=display">\begin{aligned} u_{t+1} &=m u_{t}+\frac{1}{n} \sum_{x \in \mathcal{B}} \nabla l\left(x, w_{t}\right) \\ w_{t+1} &=w_{t}-\eta u_{t+1} \end{aligned}</script><p>等价于</p><script type="math/tex; mode=display">\begin{aligned} v_{t+1} &=m v_{t}+\eta \frac{1}{n} \sum_{x \in \mathcal{B}} \nabla l\left(x, w_{t}\right) \\ w_{t+1} &=w_{t}-v_{t+1} \end{aligned}</script><p>当$\eta$ 改变时，为了保证上面两个式子的等价性，应该有</p><script type="math/tex; mode=display">v_{t+1}=m \frac{\eta_{t+1}}{\eta_{t}} v_{t}+\eta_{t+1} \frac{1}{n} \sum \nabla l\left(x, w_{t}\right)</script><blockquote><p>Remark 2: Apply momentum correction after changing learning rate if using </p><script type="math/tex; mode=display">\begin{aligned} v_{t+1} &=m v_{t}+\eta \frac{1}{n} \sum_{x \in \mathcal{B}} \nabla l\left(x, w_{t}\right) \\ w_{t+1} &=w_{t}-v_{t+1} \end{aligned}</script></blockquote><h3 id="Gradient-aggregation"><a href="#Gradient-aggregation" class="headerlink" title="Gradient aggregation"></a>Gradient aggregation</h3><blockquote><p>Normalize the per-worker loss by total minibatch size <code>kn</code>, not per-worker size <code>n</code></p></blockquote><h3 id="Data-shufﬂing"><a href="#Data-shufﬂing" class="headerlink" title="Data shufﬂing"></a>Data shufﬂing</h3><blockquote><p>Remark 4: Use a single random shufﬂing of the training data (per epoch) that is divided amongst all k workers.</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>paper notes</tag>
      
      <tag>调参</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用软件（更新）</title>
    <link href="/blog/2019/03/11/2019-03-11-software/"/>
    <url>/blog/2019/03/11/2019-03-11-software/</url>
    
    <content type="html"><![CDATA[<h2 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h2><h2 id="Snappy-Driver-Installer"><a href="#Snappy-Driver-Installer" class="headerlink" title="Snappy Driver Installer"></a>Snappy Driver Installer</h2><p><a href="https://sdi-tool.org/">url</a><br>驱动安装<br>支持 20 多款主题，Metro 适配 Win 10 效果还可以。它能自动识别硬件，并给出驱动程序下载，非常方便。Snappy Driver Installer 分为完整版和 Lite 版本，两者区别蛮大，主要是体积区别.完整版 1.18.11 (R1811）目前 17.1 GB，包含了所有驱动程序，并且只提供 BT 下载。好处当然是可以离线使用，比如装入 U 盘，就可以非常方便的为别人安装操作系统了，然后领取好人卡。而同版本号的 Lite 版本只有 4 MB，只包含主程序，没有任何驱动程序包，有简体中文。</p><h2 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h2><p>用于Windows 的文件名定位/搜索辅助软件。在目录浏览，快速启动程序方面很有效率。<br><a href="https://www.listary.com/">url</a></p><h2 id="mathpix-snipping-tool"><a href="#mathpix-snipping-tool" class="headerlink" title="mathpix snipping tool"></a>mathpix snipping tool</h2><p>用以截屏的得到latex公式的OCR工具。</p><h2 id="Axmath"><a href="#Axmath" class="headerlink" title="Axmath"></a>Axmath</h2><p><a href="http://www.amyxun.com/">url</a><br>区别：Axmath好用且便宜，Mathtype？SHIT.</p><h2 id="potplayer"><a href="#potplayer" class="headerlink" title="potplayer"></a>potplayer</h2><p>视频播放</p><h2 id="Proxifer"><a href="#Proxifer" class="headerlink" title="Proxifer"></a>Proxifer</h2><h2 id="quick-look"><a href="#quick-look" class="headerlink" title="quick look"></a>quick look</h2><p><a href="https://www.uisdc.com/quicklook-in-windows">介绍</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>software</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>import cv2 error</title>
    <link href="/blog/2018/10/23/2018-10-23-import%20cv2%20error/"/>
    <url>/blog/2018/10/23/2018-10-23-import%20cv2%20error/</url>
    
    <content type="html"><![CDATA[<blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> cv2<br><br>ImportError: dynamic <span class="hljs-built_in">module</span> does not define <span class="hljs-built_in">module</span> <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">PyInit_cv2</span>)</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>PROBLEM:</strong> The reason this was happening was that I had set the PYTHONPATH variable on Ubuntu for some other software in the past. The way Anaconda environments work is that they hard link everything that is installed into the environment. Thus each environment is a completely separate installation of Python and all the packages. By using hard links, this is done efficiently. Thus, there’s no need to mess with PYTHONPATH because the Python binary in the environment already searches the site-packages in the environment, and the lib of the environment, and so on.</p><p>By setting the PYTHONPATH environment variable we interfere with Anaconda’s natural behavior thus forcing it to look for libraries in the paths defined by the PYTHONPATH which is generally set to your local machine paths and not the environment paths.</p><p><strong>SOLUTION:</strong> Best thing to do would be to go to your <code>.bashrc</code> file and comment/remove the lines that set a <code>PYTHONPATH</code>. However, if you don’t want to do that you can always do <code>&quot;unset PYTHONPATH&quot;</code> before activating an environment and everything will work like a charm.</p><hr><p> solution from:</p><p><a href="https://github.com/udacity/CarND-Term1-Starter-Kit-Test/issues/3">https://github.com/udacity/CarND-Term1-Starter-Kit-Test/issues/3</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>show attention tell</title>
    <link href="/blog/2018/10/11/2018-10-11-show%20attend%20tell/"/>
    <url>/blog/2018/10/11/2018-10-11-show%20attend%20tell/</url>
    
    <content type="html"><![CDATA[<h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/show-attend-tell/1.jpg" alt="show_attention_tell"></p><p>流程大致如下：</p><p><strong>Encoder</strong></p><p>通过CNN的结构得到一个low level features $[a_0, \dots, a_L]$，这里得到的就是$L$个向量。</p><p><strong>Decoder : LSTM</strong></p><p>最终要得到的为$ [y_1,\dots, y_c]\quad y_i \in \mathcal{R}^K$</p><p>LSTM的输入输出为</p><script type="math/tex; mode=display">\begin{pmatrix}\textbf{i}_t \\\textbf{f}_t \\\textbf{o}_t \\\textbf{g}_t \\\end{pmatrix}=\begin{pmatrix}\sigma\\ \sigma\\ \sigma\\ \tanh \end{pmatrix}T_{D+m+n, n} \ \begin{pmatrix}E\textbf{y}_{t-1}\\ \textbf{h}_{t-1}\\ \hat{\textbf z}_t \end{pmatrix}</script><script type="math/tex; mode=display">\textbf{c}_t=\textbf{f}_t \odot \textbf{c}_{t-1} + \textbf{i}_t \odot \textbf{g}_t</script><script type="math/tex; mode=display">\textbf{h}_t = \textbf{o}_t \odot \tanh(\textbf{c}_t)</script><p> 最右边括号里的三个量是四个式子共有的三个输入量：$Ey<em>{t−1}$ 是look-up得到词 $y</em>{t−1}$ 的 m 维词向量；$h_t−1$ 是上一时刻的隐状态；<strong>$z^t∈R^D$ 是LSTM真正意义上的“输入”，</strong>代表的是捕捉了特定区域视觉信息的上下文向量，既然它和时刻 <code>t</code>有关，就说明它是一个动态变化的量，在不同的时刻将会捕捉到与本时刻相对应的相关图像区域。这个量将由attention机制计算得到。</p><p> 第二个式子是更新旧的细胞状态，element-wise 的运算表示三个门控将对各自控制的向量的每个元素做“取舍”：0 到 1 分别代表完全抛弃到完全保留。</p><p>第三个式子是得到隐状态。</p><blockquote><p>作者给出了隐状态和细胞状态的初始值的计算方式，使用两个独立的多层感知机，感知机的输入是各个图像区域特征的平均</p><script type="math/tex; mode=display">\textbf c_0=f_{\text{init,c}}(\frac1L\sum_{i=1}^L\textbf a_i)</script><script type="math/tex; mode=display">\textbf h_0=f_{\text{init,h}}(\frac1L\sum_{i=1}^L\textbf a_i)</script></blockquote><p>有了隐状态，就可以计算词表中各个词的概率值，那么取概率最大的那个作为当前时刻生成的词，并将作为下一时刻的输入。其实就是个<strong>全连接层(deep output layer)</strong>：</p><script type="math/tex; mode=display">\begin{aligned}p(\textbf{y}_t|\textbf{a}, \textbf y_1,...,\textbf y_{t-1}) \propto \exp (L_o (E \textbf{y}_{t-1} + L_h \textbf{h}_t + L_z \hat{\textbf{z}}_t))\\\\ L_o \in R^{K\times m}, L_h \in R^{m\times n}, L_z \in R^{m\times D}\end{aligned}</script><p><strong>Attention</strong></p><p>上面介绍了最后要得到 $[y_0,\dots, y_c]$，需要输入 $z_i$ ，上下文信息。那么就是如何从encoder得到的feature map得到最终的$z_i$.</p><p> 通过attention机制计算出的$z_t$ 被称为 context vector，是捕捉了特定区域视觉信息的上下文向量。</p><p> 需要明确，attention要实现的是在解码的不同时刻可以关注不同的图像区域，进而可以生成更合理的词。那么，在attention中就有两个比较关键的量，一个是和时刻 t 相关，对应于解码时刻；另一个是输入序列的区域  $a_i $，对应图像的一个区域。</p><p>实现这种机制的方式就是在时刻$ t$ ，为输入序列的各个区域$ i$ 计算出一个权重 $α<em>{ti}$ 。因为需要满足输入序列的各个区域的权重是加和为一的，使用<code>Softmax</code>来实现这一点。至于<code>Softmax</code>需要输入的信息，则如上所讲，需要包含两个方面：一个是被计算的区域 $a_i$ ，另一个就是上一时刻 t-1 的信息 $h</em>{t−1}$ </p><script type="math/tex; mode=display">e_{ti}=f_{\text{att}}(\textbf a_i,\textbf h_{t-1})</script><script type="math/tex; mode=display">\alpha_{ti}=\frac{\exp(e_{ti})}{\sum_{k=1}^L\exp(e_{tk})}</script><p>式中的 $f_{att} $是耦合计算区域 i 和时刻 t 这两个信息的打分函数。文中使用<strong>多层感知机</strong>(MLP)</p><p>有了权重，就可以计算 $z_t$ 了：</p><script type="math/tex; mode=display">\hat{\textbf z}_t=\phi(\{\textbf a_i\},\{\alpha_{ti}\})</script><p>这个函数 $ϕ$ 就代指文中提出的两种attention机制，对应于将权重施加到图像区域到两种不同的策略。</p><p><strong>soft attention</strong></p><script type="math/tex; mode=display">\text{E}_{p(s_t|a)}[\hat{z}_t]=\sum_{i=1}^{L}\alpha_{t,i}a_i</script><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/show-attend-tell/2.png" alt="soft"></p><p><strong>hard attention</strong></p><p>在soft attention中，我们采用的是加权求和的方式得到$z_t$的。前面我们得到的$\sum \alpha_i=1$，因此可以把$\alpha_i$解释为我们注意到第$i$个特征区域的可能性（置信度）。所以在hard attention中，我们是把$\alpha_i$看作从$x_i$中的采样率.</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/show-attend-tell/3.jpg" alt=""></p><p>hard attention 使用采样的方法替代了确定性的计算方法。反向传播过程中使用MC（蒙特卡洛）方法采样平均我们的计算梯度。</p><blockquote><p>Soft attention is more popular because the backpropagation seems more effective.</p></blockquote><hr><p>ref:</p><ol><li><a href="https://jhui.github.io/2017/03/15/Soft-and-hard-attention/">https://jhui.github.io/2017/03/15/Soft-and-hard-attention/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learning Deep Features for Discriminative Localization</title>
    <link href="/blog/2018/09/27/2018-09-27-CAM/"/>
    <url>/blog/2018/09/27/2018-09-27-CAM/</url>
    
    <content type="html"><![CDATA[<p>这个是周博磊16年的文章。文章通过实验证明，即使没有位置标注，CNN仍是可以得到一些位置信息，（文章中的显著性图）</p><ol><li><p>CNN提取的feature含有位置信息，尽管我们在训练的时候并没有标记位置信息；</p></li><li><p>这些位置信息，可以转移到其他的认知任务当中</p></li></ol><hr><p>文章的实验主要就是证明了，在CNN分类中，不同区域对于最终结果的影响大小是不同的，包含分类信息的部分是可以被定为得到的。（粗略的）</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/CAM/1.jpg" alt=""></p><hr><p><strong>Class Activation Mapping</strong></p><p>在传统的CNN分类任务中，最后的通常为全连接层，而FC全连接层是无法得到显著性图的。在论文中使用了GAP（global average pooling）来代替FC。</p><p>假设 $f<em>{k}(x,y)$ 表示第 $k$ 个特征图上 $(x,y)$ 位置的值，通过GAP，可以得到结果 $F_k = \sum</em>{x,y}{f_k(x,y)}$ 。 那么对于某个类别 $c$ ，<code>softmax</code>的输入值为</p><script type="math/tex; mode=display">s_{c} = \sum_{k}^{}{}w_{k}^{c}F_{k}</script><p> 最后类别$c$的值为</p><script type="math/tex; mode=display">P_{c} = \frac{exp(s_{c} )}{\sum_{c}^{}{}exp(s_{c}) }</script><p><strong>怎么通过GAP，来生成CAM</strong></p><p>通过上面的公式，我们可以将 $s_{c}$ 展开，如下所示：</p><script type="math/tex; mode=display">S_c=\sum_kw_k^c\sum_{x,y}f_k(x,y)=\sum_{x,y}\sum_kw_k^cf_k(x,y)</script><p>定义属于某个类别<code>c</code>的<code>CAM</code>为</p><script type="math/tex; mode=display">M_c(x,y)=\sum_kw_k^cf_k(x,y)</script><p>从上式可以看出，$M<em>{c}(x,y)​$ 表示的是不同的激活<code>unit</code>（特征图）对识别某个类别c的权重和。具体如下图所示。 最后将生成的 $M</em>{c}(x,y)​$ 放大到原图的大小，就可以得到对应于某个类别c的CAM了。</p><p>最后，把 $M_{c}(x,y)​$ <code>Upsample</code>到指定大小即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>instance norm</title>
    <link href="/blog/2018/09/20/2018-09-20-instance%20norm/"/>
    <url>/blog/2018/09/20/2018-09-20-instance%20norm/</url>
    
    <content type="html"><![CDATA[<p>与Batch Norm加快计算收敛不同， IN是在[1]中提出的，目的是提高style transfer的表现。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/instance-norm/1.jpg" alt=""></p><p>计算如下：</p><script type="math/tex; mode=display">IN(x)=\gamma (\frac{x-\mu(x)}{\sigma(x)}+\beta)</script><p>其中</p><script type="math/tex; mode=display">\mu_{nc}(x)=\frac{1}{HW}\sum\sum(x_{nchw})</script><script type="math/tex; mode=display">\sigma_{nc}(x)=\sqrt{\frac{1}{HW}\sum\sum(x_{nchw}-\mu_{nc}(x))^2+\epsilon}</script><p>可以看到，IN是对每个channel的计算。（感觉上跟layer norm很像。）</p><p><strong>解释</strong></p><p>关于为什么IN在style transfer和Image generation的任务上表现更好，有很多解释。这里只介绍[2]中的解释，因为实验比较充分。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/instance-norm/2.jpg" alt=""></p><p>IN作者认为IN有效的原因在于IN是对图像的对比度进行了Norm，所以效果好，但是[2]的实验表明，并非如此，如图b所示，训练图像事先对比度归一化以后，IN的表现仍然好很多。但是在均统一为一个风格以后（图c），两者差别就很小了。</p><ul><li>IN 可以认为，是一种风格的norm。即可以通过IN将图像在feature space 转化到另一个style。</li></ul><blockquote><p> Our results indicate that IN does perform a kind of style normalization.</p><p>Since BN normalizes the feature statistics of a batch of samples instead of a single sample, it can be intuitively understood as normalizing a batch of samples to be centered around a single style. Each single sample, however, may still have different styles. This is undesirable when we want to transfer all images to the same style, as is the case in the original feed-forward style transfer algorithm [51].<br>Although the convolutional layers might learn to compensate the intra-batch style difference, it poses additional challenges for training. On the other hand, IN can normalize the style of each individual sample to the target style. Training is facilitated because the rest of the network can focus on content manipulation while discarding the original style information. The reason behind the success of CIN also becomes clear: different afﬁne parameters can normalize the feature statistics to different values, thereby normalizing the output image to different styles.</p></blockquote><hr><p><strong>ref</strong></p><ol><li>Instance Normalization: The Missing Ingredient for Fast Stylization</li><li>Arbitrary Style Transfer in Real-time with Adaptive Instance Normalization</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打印梯度</title>
    <link href="/blog/2018/09/18/2018-09-18-print%20%E6%A2%AF%E5%BA%A6/"/>
    <url>/blog/2018/09/18/2018-09-18-print%20%E6%A2%AF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://pytorch.org/docs/stable/notes/autograd.html#autograd-mechanics">自动求导求梯度机制</a>相关的一个参数我们应该都熟悉，<strong>requires_grad</strong>。</p><p>当在定义一个tensor的时候并且将<strong>requires_grad</strong>设置为<strong>True。</strong>这个tensor就拥有自动求梯度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># requires_grad=False by default</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>y = torch.randn(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># requires_grad=False by default</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>z = torch.randn((<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), requires_grad=<span class="hljs-literal">True</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = x + y<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.requires_grad<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = a + z<br><span class="hljs-meta">&gt;&gt;&gt; </span>b.requires_grad<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>这是官方的示例程序，只要有一个tensor的<strong>requires_grad</strong>设置为<strong>True</strong>，那么接下来的计算中所有相关的tensor都会支持自动求导求梯度。</p><p>关于自动求导求梯度的一些信息请看这里：<a href="https://oldpan.me/archives/pytroch-torch-autograd-backward">https://oldpan.me/archives/pytroch-torch-autograd-backward</a>。</p><h2 id="register-hook"><a href="#register-hook" class="headerlink" title="register hook"></a>register hook</h2><p>但是自动求导的机制有个我们需要注意的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">In[<span class="hljs-number">2</span>]: <span class="hljs-keyword">import</span> torch<br>In[<span class="hljs-number">3</span>]: x = torch.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],dtype=torch.float32,requires_grad=<span class="hljs-literal">True</span>)<br>In[<span class="hljs-number">4</span>]: y = x * <span class="hljs-number">2</span><br>In[<span class="hljs-number">5</span>]: z = torch.mean(y)<br>In[<span class="hljs-number">6</span>]: z<br>Out[<span class="hljs-number">6</span>]: tensor(<span class="hljs-number">3.</span>)<br>In[<span class="hljs-number">7</span>]: z.backward()<br>In[<span class="hljs-number">8</span>]: x.grad<br>Out[<span class="hljs-number">8</span>]: tensor([ <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>])<br>In[<span class="hljs-number">9</span>]: y.grad    <span class="hljs-comment"># 应该为(0.5,0.5) no output</span><br>In[<span class="hljs-number">10</span>]: z.grad   <span class="hljs-comment"># 应该为1 no output</span><br></code></pre></td></tr></table></figure><p>因为在自动求导机制中只保存叶子节点，也就是中间变量在计算完成梯度后会自动释放以节省空间，所以上面代码我们在计算过程中只得到了z对x的梯度.</p><p>这就需要我们的hook函数了：</p><p>register hook (<em>hook</em>)<a href="https://pytorch.org/docs/stable/_modules/torch/tensor.html#Tensor.register_hook">[source]</a> 这个函数属于torch.tensor类，这个函数在与这个tensor梯度计算的时候就会执行，这个函数的参数hook是一个函数，这个函数应该是以下的形式：</p><p> <code>hook(grad) -&gt; Tensor or None</code>。grad是这个tensor的梯度，该函数返回grad，我们可以改变这个hook函数的返回值，但是不能改变其参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">In[<span class="hljs-number">2</span>]: <span class="hljs-keyword">import</span> torch<br>In[<span class="hljs-number">3</span>]: x = torch.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],dtype=torch.float32,requires_grad=<span class="hljs-literal">True</span>)<br>In[<span class="hljs-number">4</span>]: y = x * <span class="hljs-number">2</span><br>In[<span class="hljs-number">5</span>]: y.requires_grad<br>Out[<span class="hljs-number">5</span>]: <span class="hljs-literal">True</span><br>In[<span class="hljs-number">6</span>]: y.register_hook(<span class="hljs-built_in">print</span>)<br>Out[<span class="hljs-number">6</span>]: &lt;torch.utils.hooks.RemovableHandle at <span class="hljs-number">0x7f765e876f60</span>&gt;<br>In[<span class="hljs-number">7</span>]: z = torch.mean(y)<br>In[<span class="hljs-number">8</span>]: z.backward()<br>tensor([ <span class="hljs-number">0.5000</span>,  <span class="hljs-number">0.5000</span>])<br></code></pre></td></tr></table></figure><hr><p>refer<br><a href="https://oldpan.me/archives/pytorch-autograd-hook">https://oldpan.me/archives/pytorch-autograd-hook</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>516.最长回文子序列</title>
    <link href="/blog/2018/09/15/2018-09-15-516.%20Longest%20Palindromic%20Subsequence/"/>
    <url>/blog/2018/09/15/2018-09-15-516.%20Longest%20Palindromic%20Subsequence/</url>
    
    <content type="html"><![CDATA[<p><a href="./5.Longest Palindromic Substring.md">pre_prob 最长回文子字符串</a></p><p><strong>题目</strong></p><blockquote><p>给定字符串s，求其最长回文子序列（可以非连续）的长度</p></blockquote><hr><p><strong>DP</strong></p><blockquote><p>当已知一个序列是回文时，添加首尾元素后的序列存在两种情况，一种是首尾元素相等，则最长回文的长度加2，当首尾元素不相等，则最长回文序列为仅添加首元素时的最长回文与仅添加尾元素时的最长回文之间的最大值。我们可以用$dp[i][j]$表示$s[i…j]$中的最长回文序列，而状态转移方程则是 </p><ol><li>$i &gt; j，dp[i][j] = 0；$ </li><li>$i == j，dp[i][j] = 1；$ </li><li>$i &lt; j且s[i] == s[j]，dp[i][j] = dp[i + 1][j - 1] + 2； $</li><li>$i &lt; j且s[i]！= s[j]，dp[i][j] = max(dp[i + 1][j]，dp[i][j - 1])；$</li></ol><p>从状态转移方程可以看出，计算$dp[i][j]$时需要用到$dp[i+1][j - 1]$和$dp[i + 1][j]$，所以对于$i$的遍历应该从尾部开始，最后返回$dp[0][s.length() - 1]$就行。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindromeSubseq</span>(<span class="hljs-params">self, s</span>):</span><br>memo = [[<span class="hljs-literal">None</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br><span class="hljs-keyword">return</span> self.__shrink_recursion(s, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>, memo)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__shrink_recursion</span>(<span class="hljs-params">self, s, left, right,  memo</span>):</span><br><span class="hljs-keyword">if</span> (memo[left][right] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>):<br><span class="hljs-keyword">return</span> memo[left][right]<br><span class="hljs-keyword">if</span> (left &gt; right):<br>memo[left][right] = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> (left == right):<br>memo[left][right] = <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> (s[left] == s[right]):<br>memo[left][right] = self.__shrink(s, left+<span class="hljs-number">1</span>, right-<span class="hljs-number">1</span>, memo) + <span class="hljs-number">2</span><br><span class="hljs-keyword">else</span>:<br>memo[left][right] = <span class="hljs-built_in">max</span>(self.__shrink_recursion(s, left+<span class="hljs-number">1</span>, right, memo),\<br>                                    self.__shrink_recursion(s, left, right-<span class="hljs-number">1</span>, memo))<br><span class="hljs-comment"># print(memo)</span><br><span class="hljs-keyword">return</span> memo[left][right]<br>   <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DP_iter</span>(<span class="hljs-params">self, s</span>):</span><br>lens = <span class="hljs-built_in">len</span>(s)<br>i = j = lens // <span class="hljs-number">2</span><br>memo = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(lens-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>memo[i][i] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, lens):<br><span class="hljs-keyword">if</span> s[i] == s[j]:<br>memo[i][j] = memo[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">2</span><br><span class="hljs-keyword">else</span>:<br>memo[i][j] = <span class="hljs-built_in">max</span>(memo[i][j-<span class="hljs-number">1</span>], memo[i+<span class="hljs-number">1</span>][j])<br><span class="hljs-keyword">return</span> memo[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>]<br>   <br></code></pre></td></tr></table></figure><p>时间复杂度是$O(n^2)$，空间复杂度是$O(n^2)$。</p><hr><p><strong>改进</strong></p><blockquote><p>上述的算法，从状态转移方程来看，计算$dp[i][x]$时，只用到了$dp[i][y]$和$dp[i + 1][z]$，即计算当前行时，只用到了当前行和下一行，因此可以对上一个算法进行改进，需要用两行空间存储就能完成计算。</p><p>用一个变量cur表示当前行的下标，cur的取值为0或1，1 - cur表示的就是另外一行，因此状态转移方程变成了： </p><ol><li>$i &gt; j，dp[cur][j] = 0； $</li><li>$i == j，dp[cur][j] = 1； $</li><li>$i &lt; j且s[i] == s[j]，dp[cur][j] = dp[1 - cur][j - 1] + 2；$</li><li>$i &lt; j且s[i]！= s[j]，dp[cur][j] = max(dp[1 - cur][j]，dp[cur][j - 1])； $</li></ol><p>注意每次计算完一个$i$后需要更新$cur$的值，即$cur = 1 - cur$。因为循环执行最后一次之后会多更新一次cur，所以返回的是$dp[1 - cur][s.length() - 1]$的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">length</span>(), cur = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(<span class="hljs-number">2</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            dp[cur][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    dp[cur][j] = dp[<span class="hljs-number">1</span> - cur][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[cur][j] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span> - cur][j], dp[cur][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>            cur = <span class="hljs-number">1</span> - cur;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span> - cur][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 装饰器</title>
    <link href="/blog/2018/09/14/2018-09-14-python%20%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/blog/2018/09/14/2018-09-14-python%20%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>关于python 闭包、装饰器的介绍，可以先看廖雪峰的<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000">介绍</a></p><p>这里主要介绍上文中没有提到的部分。</p><p><strong>利用装饰器，来完成类和函数的自动注册。</strong></p><p>看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test created&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test called&quot;</span>)<br>A = Test()<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-built_in">test</span> created</span><br></code></pre></td></tr></table></figure></blockquote><p>但是我们很多时候需要根据情形来选择实例化的类，就希望类可以自动完成注册，以方便调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#装饰器代码</span><br>models = &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register_model</span>(<span class="hljs-params">model</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">**args</span>):</span><br>        models[model.__name__] = model<br>        <span class="hljs-keyword">return</span> model<br>    <span class="hljs-keyword">return</span> decorator<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_model</span>(<span class="hljs-params">name,**args</span>):</span><br>    net = models[name](**args)<br>    <span class="hljs-keyword">return</span> net<br></code></pre></td></tr></table></figure><p>这时候有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@register_model</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test created&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test called&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样通过实例化Test的时候，就完成了自动注册。</p><p>​    需要注意的是，</p><ul><li>当实例化注册的时候，<code>a = Test()</code>，类并没有立刻实例化，而是延迟的。</li><li>上面的装饰器的代码是针对单例的。</li></ul><p>此时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = Test() <span class="hljs-comment">#没有任何输出</span><br><span class="hljs-built_in">print</span>(models)<br>func =get_model(<span class="hljs-string">&quot;Test&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&#123;&#x27;Test&#x27;: &lt;class &#x27;__main__.Test&#x27;&gt;&#125;# print<br><span class="hljs-keyword">test </span>created<br></code></pre></td></tr></table></figure></blockquote><h5 id="一种我还没搞懂的方式"><a href="#一种我还没搞懂的方式" class="headerlink" title="一种我还没搞懂的方式"></a>一种我还没搞懂的方式</h5><p><code>models.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">models = &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register_model</span>(<span class="hljs-params">name</span>):</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span>(<span class="hljs-params">cls</span>):</span><br>    models[name] = cls<br>    <span class="hljs-keyword">return</span> cls<br>  <span class="hljs-keyword">return</span> decorator<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_object</span>(<span class="hljs-params">name, **args</span>):</span><br>  net = models[name](**args)<br>  <span class="hljs-keyword">return</span> net<br></code></pre></td></tr></table></figure><p><code>Test.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> models <span class="hljs-keyword">import</span> register_model, get_object<br><span class="hljs-meta">@register_model(<span class="hljs-params"><span class="hljs-string">&quot;Test&quot;</span></span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test created&quot;</span>)<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test called&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><code>main.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> models <span class="hljs-keyword">import</span> get_object<br><span class="hljs-keyword">from</span> testclass <span class="hljs-keyword">import</span> Test<br>get_object(<span class="hljs-string">&#x27;Test&#x27;</span>)()<br></code></pre></td></tr></table></figure><blockquote><p>test created<br>test called</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布度量</title>
    <link href="/blog/2018/09/10/2018-09-10-ML_DL%20%E5%88%86%E5%B8%83%E5%BA%A6%E9%87%8F/"/>
    <url>/blog/2018/09/10/2018-09-10-ML_DL%20%E5%88%86%E5%B8%83%E5%BA%A6%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/27305237">https://zhuanlan.zhihu.com/p/27305237</a></p><p>这篇文章主要总结了机器学习和统计学中一些比较常见的距离和相似度度量，稍后会把代码开源出来。计算两个向量（点、矩阵）的距离和相似度是许多机器学习算法的基础，有时候一个好的距离度量就能决定算法最后的结果好坏。比如KNN分类算法就对距离非常敏感。结合我在做的迁移学习工作，本质上就是找一个变换使得源域和目标域的距离最小（相似度最大）。所以，相似度和距离度量在机器学习中非常重要。</p><p>本文主要包括两种类型：常见的一些距离和相似度，以及针对概率分布的距离度量。代码在最后。</p><h2 id="常见距离与相似度度量"><a href="#常见距离与相似度度量" class="headerlink" title="常见距离与相似度度量"></a><strong>常见距离与相似度度量</strong></h2><h3 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h3><p>定义在两个向量（两个点）上：点$\mathbf{x}$和点$\mathbf{y}$的欧氏距离为：</p><p><img src="https://www.zhihu.com/equation?tex=d_%7BEuclidean%7D%3D%5Csqrt%7B%28%5Cmathbf%7Bx%7D-%5Cmathbf%7By%7D%29%5E%5Ctop+%28%5Cmathbf%7Bx%7D-%5Cmathbf%7By%7D%29%7D" alt="d_{Euclidean}=\sqrt{(\mathbf{x}-\mathbf{y})^\top (\mathbf{x}-\mathbf{y})}"></p><h3 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h3><p>Minkowski distance， 两个向量（点）的$p$阶距离：</p><script type="math/tex; mode=display">d_{Minkowski}=(|\mathbf{x}-\mathbf{y}|^p)^{1/p}</script><p>当$p=1$时就是曼哈顿距离，当$p=2$时就是欧氏距离。</p><h3 id="马氏距离"><a href="#马氏距离" class="headerlink" title="马氏距离"></a>马氏距离</h3><p>定义在两个向量（两个点）上，这两个点在同一个分布里。点$\mathbf{x}$和点$\mathbf{y}$的马氏距离为：</p><script type="math/tex; mode=display">d_{Mahalanobis}=\sqrt{(\mathbf{x}-\mathbf{y})^\top \Sigma^{-1} (\mathbf{x}-\mathbf{y})}</script><p>其中，$\Sigma$是这个分布的协方差。</p><p>当$\Sigma=\mathbf{I}$时，马氏距离退化为欧氏距离。</p><h3 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h3><p>定义在两个概率分布$X,Y$上，$x \in X, y \in Y$.它们的互信息为：</p><script type="math/tex; mode=display">I(X;Y)=\sum_{x \in X} \sum_{y \in Y} p(x,y) \log \frac{p(x,y)}{p(x)p(y)}</script><h3 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h3><p>衡量两个向量的相关性（夹角的余弦）。向量$\mathbf{x},\mathbf{y}$的余弦相似度为：</p><p>$\cos (\mathbf{x},\mathbf{y}) = \frac{\mathbf{x} \cdot \mathbf{y}}{\vert \mathbf{x} \vert \cdot \vert \mathbf{y} \vert }$</p><p>理解：向量的内积除以向量的数量积。</p><h3 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h3><p>衡量两个随机变量的相关性。随机变量$X,Y$的Pearson相关系数为：</p><script type="math/tex; mode=display">\rho_{X,Y}=\frac{Cov(X,Y)}{\sigma_X \sigma_Y}</script><p>理解：协方差矩阵除以标准差之积。</p><p>范围：$[-1,1]$，绝对值越大表示（正/负）相关性越大。</p><h3 id="Jaccard相关系数"><a href="#Jaccard相关系数" class="headerlink" title="Jaccard相关系数"></a>Jaccard相关系数</h3><p>对两个集合$X,Y$，判断他们的相关性，借用集合的手段：</p><script type="math/tex; mode=display">J=\frac{X \cap Y}{X \cup Y}</script><p>理解：两个集合的交集除以并集。</p><p>扩展：Jaccard距离=1-J。</p><h2 id="概率分布的距离度量"><a href="#概率分布的距离度量" class="headerlink" title="概率分布的距离度量"></a><strong>概率分布的距离度量</strong></h2><h3 id="KL散度"><a href="#KL散度" class="headerlink" title="KL散度"></a>KL散度</h3><p>Kullback–Leibler divergence，相对熵，衡量两个概率分布$P(x),Q(x)$的距离：</p><script type="math/tex; mode=display">D_{KL}(P||Q)=\sum_{i=1} P(x) \log \frac{P(x)}{Q(x)}</script><p>这是一个非对称距离：</p><script type="math/tex; mode=display">D_{KL}(P||Q) \ne D_{KL}(Q||P)</script><h3 id="JS距离"><a href="#JS距离" class="headerlink" title="JS距离"></a>JS距离</h3><p>Jensen–Shannon divergence，基于KL散度发展而来，是对称度量：</p><script type="math/tex; mode=display">JSD(P||Q)= \frac{1}{2} D_{KL}(P||M) + \frac{1}{2} D_{KL}(Q||M)</script><p>其中<script type="math/tex">M=\frac{1}{2}(P+Q)</script></p><h3 id="MMD距离"><a href="#MMD距离" class="headerlink" title="MMD距离"></a>MMD距离</h3><p>Maximum mean discrepancy，度量在再生希尔伯特空间中两个分布的距离，是一种核学习方法。两个随机变量的距离为：</p><script type="math/tex; mode=display">MMD(X,Y)=\left \Vert \sum_{i=1}^{n_1}\phi(\mathbf{x}_i)- \sum_{j=1}^{n_2}\phi(\mathbf{y}_j) \right \Vert^2_\mathcal{H}</script><p>其中<script type="math/tex">\phi(\cdot)</script>是映射，用于把原变量映射到高维空间中。</p><p>理解：就是求两堆数据在高维空间中的均值的距离。</p><h3 id="Principal-angle"><a href="#Principal-angle" class="headerlink" title="Principal angle"></a>Principal angle</h3><p>也是将两个分布映射到高维空间（格拉斯曼流形）中，在流形中两堆数据就可以看成两个点。Principal angle是求这两堆数据的对应维度的夹角之和。对于两个矩阵$\mathbf{X},\mathbf{Y}$，计算方法：首先正交化（用PCA）两个矩阵，然后：</p><script type="math/tex; mode=display">PA(\mathbf{X},\mathbf{Y})=\sum_{i=1}^{\min(m,n)} \sin \theta_i</script><p>其中$m,n$分别是两个矩阵的维度，$\theta_i$是两个矩阵第$i$个维度的夹角，$\Theta={\theta_1,\theta_2,\cdots,\theta_t}$是两个矩阵SVD后的角度：</p><script type="math/tex; mode=display">\mathbf{X}^\top\mathbf{Y}=\mathbf{U} (\cos \Theta) \mathbf{V}^\top</script><h3 id="HSIC"><a href="#HSIC" class="headerlink" title="HSIC"></a>HSIC</h3><p>希尔伯特-施密特独立性系数，Hilbert-Schmidt Independence Criterion，用来检验两组数据的独立性：</p><script type="math/tex; mode=display">HSIC(X,Y) = trace(HXHY)</script><p>其中$X,Y$是两堆数据的kernel形式。</p><h3 id="Earth-Mover’s-Distance"><a href="#Earth-Mover’s-Distance" class="headerlink" title="Earth Mover’s Distance"></a>Earth Mover’s Distance</h3><p>推土机距离，度量两个分布之间的距离，又叫Wasserstein distance。以最优运输的观点来看，就是分布$X$能够变换成分布$Y$所需要的最小代价：</p><p>一个二分图上的流问题，最小代价就是最小流，用匈牙利算法可以解决。</p><script type="math/tex; mode=display">emd(X,Y)=\min{\frac{\sum_{i,j}f_{ij}d(\textbf{x}_i,\textbf{y}_j)}{\sum_{j}w_{yj}}}, s.t. \sum_{i}f_{ij}=w_{yj}, \sum_{j}f_{ij}=w_{xi}.</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>可用的代码我找了一个比较全的，用matlab写的，特别简单，直接可以用，输入是两个矩阵，输出是各种距离。地址在这里：<a href="https://link.zhihu.com/?target=https%3A//github.com/shicai/matlab/blob/master/sc_pdist2.m">shicai/matlab</a></p><p><strong>References</strong></p><p>[1] <a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/pipisorry/article/details/45651315">距离和相似度度量方法 - 皮皮blog - 博客频道 - CSDN.NET</a></p><p>[2]<a href="https://link.zhihu.com/?target=http%3A//chaofan.io/archives/earth-movers-distance-%25E6%258E%25A8%25E5%259C%259F%25E6%259C%25BA%25E8%25B7%259D%25E7%25A6%25BB">Earth Mover’s Distance — 推土机距离</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.Longest Palindromic Substring</title>
    <link href="/blog/2018/09/09/2018-09-09-5.Longest%20Palindromic%20Substring/"/>
    <url>/blog/2018/09/09/2018-09-09-5.Longest%20Palindromic%20Substring/</url>
    
    <content type="html"><![CDATA[<blockquote><p>连续最长回文字符串</p><p><strong>Example 1:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&gt;<span class="hljs-keyword">Input</span>: &quot;babad&quot;<br>&gt;Output: &quot;bab&quot;<br>&gt;Note: &quot;aba&quot; <span class="hljs-keyword">is</span> <span class="hljs-keyword">also</span> a <span class="hljs-keyword">valid</span> answer.<br></code></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">&gt;<span class="hljs-meta">Input</span>: <span class="hljs-string">&quot;cbbd&quot;</span><br>&gt;<span class="hljs-meta">Output</span>: <span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>brute force</strong></p><blockquote><p>就是暴力搜索。</p><p>三层循环，左右边界以及判断是否为回文字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">brute_force</span>(<span class="hljs-params">s</span>):</span><br>    pal_str =<span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">while</span> i &lt;= j:<br>                <span class="hljs-keyword">if</span> s[i] != s[j]:<br>                    <span class="hljs-keyword">continue</span><br>                i += <span class="hljs-number">1</span><br>                j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pal_str) &lt; j-i+<span class="hljs-number">1</span>;<br>        pal_str=s[i,j+<span class="hljs-number">1</span>]<br>  <span class="hljs-keyword">return</span> pal_str<br></code></pre></td></tr></table></figure><p> <strong>Dynamic Programming</strong></p><blockquote><p>考虑”ababa”的例子，如果知道’”bab”‘是回文串，那么边上两个字母相同，就有整个字符串为回文字串。</p><p>定义$P(i,j)$</p><script type="math/tex; mode=display">P(i,j)=\left\{ \begin{aligned}    \text{True}   &\quad  S_{i,j}\text{是回文串}\\    \text{False}  &\quad  \text{其他}\end{aligned} \right.</script><p>显然有</p><script type="math/tex; mode=display">P(i,j)=(P(i+1,j−1) \quad \text{and} \quad S_i==S_j)</script><p>而且有 </p><script type="math/tex; mode=display">\begin{aligned}P(i,i) &= true \\P(i, i+1) &= (S_i == S_{i+1} )\end{aligned}</script></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DP</span>(<span class="hljs-params">s</span>):</span><br>  table = [[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>sub_str = <span class="hljs-string">&quot;&quot;</span><br>lens = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> lens &lt; <span class="hljs-built_in">len</span>(s):<br><span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>end = start + lens -<span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> end &gt;= <span class="hljs-built_in">len</span>(s):<br><span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(start, end)<br>table[start][end] = (lens == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> lens == <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> table[start+<span class="hljs-number">1</span>][end-<span class="hljs-number">1</span>]) \<br> <span class="hljs-keyword">and</span> s[start] == s[end]<br><span class="hljs-keyword">if</span> table[start][end] <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(sub_str) &lt; end-start +<span class="hljs-number">1</span>:<br>sub_str = s[start:end+<span class="hljs-number">1</span>]<br>lens += <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> sub_str<br></code></pre></td></tr></table></figure><p><strong>Expand Around Center</strong></p><blockquote><p>对于任一字符，依此为中心向两边扩展。直到不是回文串为止。记录长度最大的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expandAroundCenter</span>(<span class="hljs-params">s</span>):</span><br>start = <span class="hljs-number">0</span> <br>end = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>len1 = expand(s, i, i)<br>len2 = expand(s, i, i+<span class="hljs-number">1</span>)<br>max_len = <span class="hljs-built_in">max</span>(len1,len2)<br><br><span class="hljs-keyword">if</span> max_len &gt;= end -start + <span class="hljs-number">1</span>:<br>start = i - <span class="hljs-built_in">int</span>((max_len - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span>)<br>end   = i + <span class="hljs-built_in">int</span>(max_len // <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> s[start:end + <span class="hljs-number">1</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">expand</span>(<span class="hljs-params">s, left, right</span>):</span><br>L = left<br>R = right<br><span class="hljs-keyword">while</span> L &gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> R &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> s[L] == s[R]:<br>L -= <span class="hljs-number">1</span><br>R += <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> R - L - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>Manacher’s Algorithm 马拉车算法</strong></p><blockquote><p> 利用已知的对称信息和回文串的对称性得出其他位置的对称信息，并且不用考虑字符串长度是奇数还是偶数的，因为首先我们对字符串进行处理：在字符串的首尾和字符间加上<code>&quot;#&quot;</code>，如<code>&quot;nbbn&quot;</code>改变后为<code>&quot;#n#b#b#n#&quot;</code>，再在首位加上<code>&quot;&amp;&quot;</code>，所以最终经过处理的字符串为<code>&quot;&amp;#n#b#b#n#&quot;</code>。另外我们还需要辅助一个和处理后长度一致的int数组，该数组用来存字符串对应位置的最长回文长度加上本身（就是最长回文数+1），如下：</p><p><a href="http://images.jucongyuan.com/QQ20160825-0.png"><img src="http://images.jucongyuan.com/QQ20160825-0.png" alt="Happy"></a></p><p>如字符串第二个<code>b</code>两边对称的长度为1，所以它对应的int数组内的值为2。有了这个表格，我们就知道，只要求出字符串对应位置上int数组的值，那么回文串自然就出来了，那int[]数组怎么求出来呢？也就是怎么利用已知的对称信息和回文串的对称性得出其他位置的对称信息呢？首先假设最长回文所在位置为id，到最长回文长度的位置为idMax,如果我们要求i位置上的最长回文长度（也就是int[i]的值），可以根据int[j]的值，前提条件是(0&lt;=j&lt;i,所以int[j]是已知的)，那么是什么原理呢？分为两种情况：</p><ul><li><strong>i &lt;= idMax，通过id的位置找到和i位置对称的j点</strong></li></ul><p><a href="http://images.jucongyuan.com/QQ20160825-1.png"><img src="http://images.jucongyuan.com/QQ20160825-1.png" alt="Happy"></a></p><ul><li><p><strong>如过<code>int[j] &lt; idMax - i</code>，那么<code>int[i]</code>就等于<code>int[j]</code>。</strong></p><blockquote><p>对称的半径在范围以内</p></blockquote></li><li><p><strong>如果<code>int[j] &gt;= idMax - i</code>，那么<code>int[i]</code>的值大于或者等于<code>int[j]</code>。然后再在这个位置继续向左右延伸判断是否还有回文长度。</strong></p><blockquote><p>此时显然不满足对称关系了，因为越界了。</p></blockquote></li><li><p><strong><code>i &gt; idMax</code>时，所以中心点为i的回文还没有匹配，只有通过循环去匹配了。</strong></p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.length() &lt;= <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> s;    <br>    &#125; <br>    StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;$&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>        stringBuilder.append(<span class="hljs-string">&quot;#&quot;</span>);<br>        stringBuilder.append(c);<br>    &#125;<br>    stringBuilder.append(<span class="hljs-string">&quot;#&quot;</span>);<br>    String str = stringBuilder.toString();<br><br>    <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> idMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxLength = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> p[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[str.length()];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> curr = <span class="hljs-number">1</span>; curr &lt; str.length(); curr++) &#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * id - curr;<br><br>        <span class="hljs-comment">// p[curr] = idMax &gt; curr ? Math.min(p[symmetryId], idMax - curr) : 1;</span><br>        <span class="hljs-comment">// 更容易理解的写法</span><br>        <span class="hljs-keyword">if</span> (idMax &gt; curr)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (p[j] &lt; idMax - curr)<br>                p[curr] = p[j];<br>            <span class="hljs-keyword">else</span><br>                p[curr] = idMax - curr;<br>        &#125; <br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            p[curr] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (curr + p[curr] &lt; str.length() &amp;&amp; str.charAt(curr + p[curr]) \<br>               == str.charAt(curr - p[curr])) &#123;<br>            p[curr]++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (curr + p[curr] &gt; idMax) &#123;<br>            id = curr;<br>            idMax = curr + p[curr];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (p[curr] &gt; maxLength) &#123;<br>            maxLength = p[curr];<br>            index = curr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.substring((index - maxLength) / <span class="hljs-number">2</span>, (index + maxLength) / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53.最大子序列和</title>
    <link href="/blog/2018/09/07/2018-09-07-53.%20Maximum%20Subarray/"/>
    <url>/blog/2018/09/07/2018-09-07-53.%20Maximum%20Subarray/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于给定序列，得到最大和的子序列</p><p><strong>Example:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&gt;Input: [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4],<br>&gt;Output: 6<br>&gt;Explanation: [4,<span class="hljs-string">-1</span>,2,1] has the largest sum = 6.<br></code></pre></td></tr></table></figure></blockquote><p><strong>brute force</strong></p><blockquote><p>遍历所有的可能答案，得到最大子序列和。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">brute_force</span>(<span class="hljs-params">nums</span>):</span><br>    max_sum = <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<span class="hljs-comment"># 左边界</span><br>        <span class="hljs-keyword">for</span> R <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(L,<span class="hljs-built_in">len</span>(nums)):<span class="hljs-comment"># 右边界</span><br>            cur_sum = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(L,R):<br>                cur_sum+=nums[i]<br>            <span class="hljs-keyword">if</span> cur_sum &gt; max_sum:<br>                max_sum = cur_sum<br>    <span class="hljs-keyword">return</span> max_sum<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n^3)$</p><p><strong>改进版穷举</strong></p><blockquote><p>上面的方法，可以改进，去掉最内层的循环。以左边界为起点，记录连续的求和，只取最大的即可。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">brute_force</span>(<span class="hljs-params">nums</span>):</span><br>    max_sum = <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> L <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<span class="hljs-comment"># 左边界</span><br>        cur_sum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> R <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(L,<span class="hljs-built_in">len</span>(nums)):<br>            cur_sum+=nums[R]<br>            <span class="hljs-keyword">if</span> cur_sum &gt; max_sum:<br>                max_sum = cur_sum<br>    <span class="hljs-keyword">return</span> max_sum<br></code></pre></td></tr></table></figure><p>此时时间复杂度$O(n^2)$</p><p><strong>分治</strong></p><blockquote><p>这个问题可以递归求解，</p><p>在例子中，最大子序列的和只可能出现在3个地方：</p><ol><li>出现在输入数据的左半部分</li><li>出现在输入数据的右半部分</li><li>跨越输入数据的中部而位于左右两个部分</li></ol><p>前两种情况可以递归求解，第三种情况的最大和可以通过求出前半部分（包含前半部分的最后一个元素）的最大和以及后半部分（包括后半部分的第一个元素）的最大和，再将二者相加得到。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Devided_Conquer</span>(<span class="hljs-params">nums, left, right</span>):</span><br>  <span class="hljs-keyword">if</span> left == right:<br>    <span class="hljs-keyword">return</span> nums[left] <span class="hljs-comment">#if nums[left] &gt; 0 else 0</span><br>  <br>  center = (left+right) // <span class="hljs-number">2</span><br>  max_left  = Devided_Conquer(nums, left, center)<br>  max_right = Devided_Conquer(nums, center+<span class="hljs-number">1</span>, right)<br>  <br>  left_Sum = <span class="hljs-number">0</span><br>  maxLeft_Sum = nums[center]<br><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(center, left-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>    left_Sum += nums[i]<br>    <span class="hljs-keyword">if</span> left_Sum &gt; maxLeft_Sum:<br>      maxLeft_Sum = left_Sum<br>  <br>  right_sum = <span class="hljs-number">0</span><br>  max_right_sum = nums[center+<span class="hljs-number">1</span>] <br><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(center+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>):<br>    right_sum += nums[i]<br>    <span class="hljs-keyword">if</span> right_sum &gt; max_right_sum:<br>      max_right_sum = right_sum<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(max_left, max_right, maxLeft_Sum+max_right_sum)<br></code></pre></td></tr></table></figure><p>时间复杂度 $O (N\log N)$</p><p><strong>One-Pass</strong></p><blockquote><p>考虑</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">One_Pass</span>(<span class="hljs-params">nums</span>):</span><br>    max_sum = nums[<span class="hljs-number">0</span>]<br>    this_sum = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums[<span class="hljs-number">1</span>:]:<br>        this_sum = <span class="hljs-built_in">max</span>(num, this_sum+num)<br>        <span class="hljs-keyword">if</span> this_sum &gt; max_sum:<br>            max_sum = this_sum<br>    <span class="hljs-keyword">return</span> max_sum<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>122.Best Time to Buy and Sell Stock II</title>
    <link href="/blog/2018/09/06/2018-09-06-122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/"/>
    <url>/blog/2018/09/06/2018-09-06-122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/</url>
    
    <content type="html"><![CDATA[<blockquote><p>与<a href="./121. Best Time to Buy and Sell Stock .md">121</a>不同的在于，121只能操作一次，而这个是可以操作任意次。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>:<span class="hljs-meta"> [7,1,5,3,6,4]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">7</span><br><span class="hljs-attribute">Explanation</span>: Buy <span class="hljs-literal">on</span> day <span class="hljs-number">2</span> (price = <span class="hljs-number">1</span>) and sell <span class="hljs-literal">on</span> day <span class="hljs-number">3</span> (price = <span class="hljs-number">5</span>), profit = <span class="hljs-number">5</span>-<span class="hljs-number">1</span> = <span class="hljs-number">4</span>.Then buy <span class="hljs-literal">on</span> day <span class="hljs-number">4</span> (price = <span class="hljs-number">3</span>) and sell <span class="hljs-literal">on</span> day <span class="hljs-number">5</span> (price = <span class="hljs-number">6</span>), profit = <span class="hljs-number">6</span>-<span class="hljs-number">3</span> = <span class="hljs-number">3</span>.<br></code></pre></td></tr></table></figure></blockquote><hr><p><strong>brute force</strong></p><blockquote><p>暴力搜索，没什么好说的</p><p>当前位置 $i$ ，搜索其后所有的可能答案，取最大的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">brute_force</span>(<span class="hljs-params">arr, start</span>):</span><br>  <span class="hljs-keyword">if</span> start &gt;= <span class="hljs-built_in">len</span>(arr):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  max_profit = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, <span class="hljs-built_in">len</span>(arr)):<br>    tmp_max_profit = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr)):<br>      <span class="hljs-keyword">if</span> arr[j] &gt; arr[i]:<br>        profit = brute_force(arr, j+<span class="hljs-number">1</span>) + arr[j] - arr[i]<br>        <span class="hljs-keyword">if</span> profit &gt; tmp_max_profit:<br>          tmp_max_profit = profit<br>    <span class="hljs-keyword">if</span> tmp_max_profit&gt;max_profit:<br>      max_profit = tmp_max_profit<br>  <span class="hljs-keyword">return</span> max_profit<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n^n)$ ， 空间复杂度$O(n)$</p><hr><p> <strong>Peak Valley Approach</strong></p><blockquote><p>给定的<code>price</code>数组为$[7, 1, 5, 3, 6, 4]$. 绘制图片有（来自<a href="https://leetcode.com/media/original_images/122_maxprofit_1.PNG">leetcode</a>）</p><p><img src="https://leetcode.com/media/original_images/122_maxprofit_1.PNG" alt=""></p><p>显然有，最终的收益来自于所有的峰值减去谷值之和</p><p>$Total_Profit = \sum_i(height(peak_i)-height(valley_i))$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Peak_Valley</span>(<span class="hljs-params">prices</span>):</span><br>  valley = prices[<span class="hljs-number">0</span>]<br>  peak  = prices[<span class="hljs-number">0</span>]<br>  idx = <span class="hljs-number">0</span><br>  max_profit = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> idx &lt; <span class="hljs-built_in">len</span>(prices)-<span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">while</span> idx &lt; <span class="hljs-built_in">len</span>(prices)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> prices[idx+<span class="hljs-number">1</span>] &lt;= prices[idx]:<br>      idx+=<span class="hljs-number">1</span><br>    vally = prices[idx]<br>    <span class="hljs-keyword">while</span> idx &lt; <span class="hljs-built_in">len</span>(prices)-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> prices[idx+<span class="hljs-number">1</span>] &gt; prices[idx]:<br>      idx+=<span class="hljs-number">1</span><br>    peak = prices[idx]<br>    max_profit += peak-vally<br>  <span class="hljs-keyword">return</span> max_profit<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n)$, 空间复杂度$O(1)$</p><hr><p><strong>Simple One Pass</strong></p><blockquote><p>跟上面略微不同的是，只要斜率是正的，就一直买入卖出就可以获得最大利润</p><p><img src="https://leetcode.com/media/original_images/122_maxprofit_2.PNG" alt="Profit Graph"></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">One_Pass</span>(<span class="hljs-params">prices</span>):</span><br>  max_profit = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> idx, price <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(prices):<br>    <span class="hljs-keyword">if</span> idx &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> price &gt; prices[idx-<span class="hljs-number">1</span>]:<br>      max_profit += price-prices[idx-<span class="hljs-number">1</span>]<br>  <span class="hljs-keyword">return</span> max_profit<br>        <br></code></pre></td></tr></table></figure><p>时间复杂度$O(n)$, 空间复杂度$O(1)$</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70. climbing stairs</title>
    <link href="/blog/2018/09/05/2018-09-05-70.Climbing%20Stairs/"/>
    <url>/blog/2018/09/05/2018-09-05-70.Climbing%20Stairs/</url>
    
    <content type="html"><![CDATA[<p><strong>描述</strong></p><blockquote><p>n阶楼梯，每次一步或者两步，一共有多少种方法</p></blockquote><p><a href="../prob_70_Climbing Stairs.py">Solutions</a></p><p><strong>brute_force</strong></p><blockquote><p>$f(n)=f(n-1)+f(n-2)$</p><p>显然有，到第n阶楼梯有两种方法，从n-1过去，和n-2过去。即到n阶的方法等于这两种方法的和</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">brute_force</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">return</span> brute_force(n-<span class="hljs-number">1</span>)+brute_force(n-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>这种方法的时间复杂度为 $2^n$. 图片来自于<a href="https://leetcode.com/problems/climbing-stairs/solution/">leetcode</a><img src="https://leetcode.com/problems/climbing-stairs/Figures/70_Climbing_Stairs_rt.jpg" alt="Climbing_Stairs"></p><p><strong>带记忆的递归计算</strong></p><blockquote><p>在上面的计算中，显然有大量的重复计算，如果这个数值已经存下来了，就可以减小运算时间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">memo = &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recursion_memo</span>(<span class="hljs-params">n, memo</span>):</span><br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n ==<span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> memo.keys():<br>        <span class="hljs-keyword">return</span> memo[n]<br>    value = recursion_memo(n-<span class="hljs-number">1</span>, memo) + recursion_memo(n-<span class="hljs-number">2</span>, memo)<br>    memo.update(&#123;n:value&#125;)<br>    <span class="hljs-keyword">return</span> memo[n]<br></code></pre></td></tr></table></figure><p><strong>动态规划</strong></p><blockquote><p>在暴力搜索里提到了，$f(n)=f(n-1)+f(n-2)$</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dynamic</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> n<br>    result = [<span class="hljs-number">0</span>]*(n)<br>    result[<span class="hljs-number">0</span>] =<span class="hljs-number">1</span><br>    result[<span class="hljs-number">1</span>] =<span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n):<br>        result[i] = result[i-<span class="hljs-number">1</span>]+result[i-<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">return</span> result[n-<span class="hljs-number">1</span>]<br>        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python多线程</title>
    <link href="/blog/2018/09/01/2018-09-01-python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/blog/2018/09/01/2018-09-01-python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="http://python.jobbole.com/87498/?repeat=w3tc">介绍</a></p><p><a href="http://python.jobbole.com/86917/">more </a></p><p><strong>single threading</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_square</span>(<span class="hljs-params">numbers</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;caculating square numbers&quot;</span>)<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers:<br>        time.sleep(<span class="hljs-number">0.2</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;square:&#x27;</span>, n**<span class="hljs-number">2</span>)<br>    <br> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_cube</span>(<span class="hljs-params">numbers</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;caculating cube of numbers&quot;</span>)<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers:<br>        time.sleep(<span class="hljs-number">0.2</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;cube:&#x27;</span>, n**<span class="hljs-number">3</span>)<br>        <br>arr = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>calc_sqare(arr)<br>calc_cube(arr)<br></code></pre></td></tr></table></figure><p><strong>multi-threading</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_square</span>(<span class="hljs-params">numbers</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;calculating square numbers&quot;</span>)<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers:<br>        time.sleep(<span class="hljs-number">0.2</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;square:&#x27;</span>, n**<span class="hljs-number">2</span>)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_cube</span>(<span class="hljs-params">numbers</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;calculating cube of numbers&quot;</span>)<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers:<br>        time.sleep(<span class="hljs-number">0.2</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;cube:&#x27;</span>, n**<span class="hljs-number">3</span>)<br>        <br>arr = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br>t1 = theading.Thread(target= calc_square, args=(arr,))<br>t2 = theading.Thread(target= calc_cube, args=(arr,))<br>t1.start()<br>t2.start()<br><br>t1.join()<br>t2.join()<br><br>calc_sqare(arr)<br>calc_cube(arr)<br></code></pre></td></tr></table></figure><p>output</p><blockquote><p>calculating square numbers<br>calculating cube of numbers<br>square: 4<br>cube: 8<br>cube: 27<br>square: 9<br>cube: 64<br>square: 16<br>cube: 125<br>square: 25</p><p><strong>no join()</strong></p><p>calculating square numbers<br>calculating cube of numbers<br>square: 4<br>cube: 8<br>square: 9<br>cube: 27<br>square: 16<br>cube: 64<br>square: 25<br>cube: 125</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pyramid Scene Parsing Network</title>
    <link href="/blog/2018/08/20/2018-08-20-PSP%20Network/"/>
    <url>/blog/2018/08/20/2018-08-20-PSP%20Network/</url>
    
    <content type="html"><![CDATA[<p>解决的问题：(FCN)</p><ul><li>Mismatched Relationship: 匹配关系错误，如将在水中的船识别为车。</li><li>Confusion Categories: 模糊的分类，如 hill 和 mountain的区分。</li><li>Inconspicuous classes: 无视小尺寸物品。</li></ul><p>这些错误与语义间的关系以及不同感知区域的全局信息有关。</p><p>通常情况下，我们可以粗略认为，卷积层卷积核大小（感知域）能够表示结构考虑了多大范围的context。然而，在研究中表面，卷积层实际感知域小于理论。因此，很多结构并不能很好地表现全局信息。（即进行分割任务的时候，不能很好的利用全局信息来约束分割效果） </p><p><strong>PSPNet 结构</strong></p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PSP-Network/1.jpg" alt="PSPnet"></p><ul><li>上图结构首先将输入图片(a)用<code>ResNet</code>提取成特征图(b)。</li><li>通过pyramid pooling modules 来进行不同尺寸的池化。文章中将特征图大小分别池化为：<code>1x1,2x2,3x3,6x6</code>。并通过一个卷积层将每个特征通道数变为feature map通道数的<code>1/N</code>，其中N为级数，此时N=4。</li><li><p>最后将池化结果上采样(文中使用了双线性插值)，与特征图(b)连接后，通过卷积层输出结果。</p><p>这个结构与FCN不同的是，它<strong>通过pyramid的池化层考虑了不同尺寸的全局信息</strong>。而在FCN中只考虑了某一个池化层，如FCN-16s 只考虑pool4。 </p></li></ul><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PSP-Network/2.jpg" alt=""></p><p><strong>辅助loss</strong></p><p>文中还提到了为了训练使用了一个辅助的loss，<strong>网络越深性能越好，但是也越难训练.</strong>(ResNet solves this problem with skip connection in each block”。作者在网络中间引入了一个额外的loss函数，这个loss函数和网络输出层的loss pass through all previous layers，图示如下 </p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/PSP-Network/3.jpg" alt="loss"></p><p>其中loss1是最终的分割loss（softmax_loss），loss2是添加的辅助loss，二类分交叉熵函数，（多分类问题）</p><p><strong>实现细节</strong></p><ul><li>图片输入的CNN是ResNet，使用了dilated convolution</li><li>Pyramid Pooling Module中的conv是１×１的卷积层，为了减小维度和维持全局特征的权重</li><li>Pyramid Pooling Module中的pooling的数量以及尺寸都是可以调节的</li><li>上采样使用的双线性插值</li><li>poly learning rate policy</li><li>数据扩增用了：random mirror, random resize(0.5-2), random rotation(-10到10度), random Gaussian blur</li><li>选取合适的batchsize</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>caffe install  16</title>
    <link href="/blog/2018/08/20/2018-08-20-caffe%20install%20%2016.04/"/>
    <url>/blog/2018/08/20/2018-08-20-caffe%20install%20%2016.04/</url>
    
    <content type="html"><![CDATA[<ol><li><p>安装依赖</p><blockquote><p>sudo apt-get install python-pip</p><p>sudo pip install easydict protobuf pydot</p><p>sudo apt-get install graphviz libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler libopenblas-dev liblapack-dev libatlas-base-dev libgflags-dev libgoogle-glog-dev liblmdb-dev python-tk python-numpy python-scipy python-matplotlib python-sklearn python-skimage python-h5py python-protobuf python-leveldb python-networkx python-nose python-pandas python-gflags</p><p>sudo apt-get install —no-install-recommends libboost-all-dev</p></blockquote></li><li><p>nvidia-smi 驱动以及CUDA cudnn</p></li><li><p>配置caffe</p><ul><li><p>下载caffe</p></li><li><p>配置caffe文件</p><blockquote><p>cd  caffe（具体路径自己改）</p><p>sudo cp Makefile.config.example Makefile.config</p><p>sudo gedit Makefile.config</p><p>USE_CUDNN := 1#去掉这个注释，因为要使用cudnn（但是假如显卡太低级，兼容性不够，就用不了cudnn）</p><p># CPU_ONLY := 1#加上这个注释（因为要使用cuda，所以就不用改）</p><p>WITH_PYTHON_LAYER := 1 #去掉这个注释，因为以后经常会用到caffe 的 Python layer</p><p>然后根据自己的cuda根据该文档提示删去或者注释掉相应的版本的，例如</p><p>CUDA_ARCH := #-gencode arch=compute_20,code=sm_20 \</p><p>#-gencode arch=compute_20,code=sm_21 \（要根据自己实际才cuda版本注释，文件本身有提示）</p><p>将</p><p>INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include</p><p>LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib</p><p>修改为：</p><p>INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/include/hdf5/serial</p><p>LIBRARY_DIRS := $(PYTHON_LIB) /usr/lib/x86_64-linux-gnu/hdf5/serial（一般是这两条，具体路径可以自己看机器的hdf5文件夹路径）</p><p>保存退出。</p></blockquote></li><li><p>编译caffe</p><blockquote><p>sudo make all -j16 （在make pycaffe -j16前的话会有很多编译错误，以后的bug）</p><p>sudo make runtest -j16（测试）</p><p>sudo make pycaffe -j16（警告不用在意，在make all -j16前会好一点，很少error）</p><p>sudo make pytest -j16</p><p>若报错，则需要</p><p>sudo make clean</p><p>然后修改错误后，重新编译编译caffe</p></blockquote></li></ul></li><li><p>错误处理</p><ul><li><p><strong>m//home/yali/anaconda2/lib/libpng16.so.16：对‘inflateValidate@ZLIB_1.2.9’未定义的引用</strong>   </p><p>正确解决方法：  </p><blockquote><p>在 Makefile.config 中，加入下一句  LINKFLAGS := -Wl,-rpath,$(HOME)/anaconda3/lib</p></blockquote></li></ul></li><li></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>caffe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>746.最小代价爬楼梯</title>
    <link href="/blog/2018/08/03/2018-08-03-Min%20Cost%20Climbing%20Stairs/"/>
    <url>/blog/2018/08/03/2018-08-03-Min%20Cost%20Climbing%20Stairs/</url>
    
    <content type="html"><![CDATA[<p>每爬一层楼梯需要支付一定的代价，支付以后可以选择爬一层或者两层。那个找到最小代价。</p><p><strong>Example :</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Input</span>: <span class="hljs-keyword">cost</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>]<br>Output: <span class="hljs-number">6</span><br>Explanation: Cheapest <span class="hljs-keyword">is</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">on</span> <span class="hljs-keyword">cost</span>[<span class="hljs-number">0</span>], <span class="hljs-keyword">and</span> <span class="hljs-keyword">only</span> step <span class="hljs-keyword">on</span> <span class="hljs-number">1</span>s, skipping <span class="hljs-keyword">cost</span>[<span class="hljs-number">3</span>].<br></code></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>cost</code> will have a length in the range <code>[2, 1000]</code>.</li><li>Every <code>cost[i]</code> will be an integer in the range <code>[0, 999]</code>.</li></ol><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>典型的动态规划的题目。</p><p>最终的cost为 <code>f[i] = cost[i] + min(f[i-1],f[i-2])</code> 即当前的cost是当前加上前面最小的cost。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/Min-Cost-Climbing-Stairs/1.jpg" alt=""></p><p>所以只要记录前面两步的cost即可。开始的时候认为这个是0.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span>(<span class="hljs-params">cost</span>):</span><br>        f1 = f2 = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> cost:<br>            f1, f2 = x + <span class="hljs-built_in">min</span>(f1, f2), f1<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(f1, f2)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>121. Best Time to Buy and Sell Stock</title>
    <link href="/blog/2018/08/02/2018-08-02-121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20/"/>
    <url>/blog/2018/08/02/2018-08-02-121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20/</url>
    
    <content type="html"><![CDATA[<p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Note that you cannot sell a stock before you buy one.</p><p><strong>Example 1:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>:<span class="hljs-meta"> [7,1,5,3,6,4]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">5</span><br><span class="hljs-attribute">Explanation</span>: Buy <span class="hljs-literal">on</span> day <span class="hljs-number">2</span> (price = <span class="hljs-number">1</span>) and sell <span class="hljs-literal">on</span> day <span class="hljs-number">5</span> (price = <span class="hljs-number">6</span>), profit = <span class="hljs-number">6</span>-<span class="hljs-number">1</span> = <span class="hljs-number">5</span>.<br>             <span class="hljs-attribute">Not</span> <span class="hljs-number">7</span>-<span class="hljs-number">1</span> = <span class="hljs-number">6</span>, as selling price needs to be larger than buying price.<br></code></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Input</span>: [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>Output: <span class="hljs-number">0</span><br>Explanation: <span class="hljs-keyword">In</span> this <span class="hljs-keyword">case</span>, <span class="hljs-keyword">no</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">is</span> done, i.e. max profit = <span class="hljs-number">0.</span><br></code></pre></td></tr></table></figure><p>题目要求为，选择最佳的买入卖出时间，得到最大收益。</p><h2 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h2><p>复杂度$O(n^2)$ 确切一点是 $O(\frac{n(n+1)}{2})$</p><h2 id="one-pass"><a href="#one-pass" class="headerlink" title="one pass"></a>one pass</h2><p>对于$[7, 1, 5, 3, 6, 4] $</p><p><img src="https://leetcode.com/media/original_images/121_profit_graph.png" alt="Profit Graph"> </p><p>可以知道，我们感兴趣的是峰谷之间的差值。则我们只需要找到当前值与之前最小值的最大差值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prices[])</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> minprice = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">int</span> maxprofit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minprice)<br>                minprice = prices[i];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prices[i] - minprice &gt; maxprofit)<br>                maxprofit = prices[i] - minprice;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxprofit;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>global average pooling</title>
    <link href="/blog/2018/08/01/2018-08-01-global%20average%20pooling/"/>
    <url>/blog/2018/08/01/2018-08-01-global%20average%20pooling/</url>
    
    <content type="html"><![CDATA[<p>首先需要对深度网络中常见的pooling方式，以及全连接层有大致的了解。（此处略过不提。）</p><p>paper: <a href="https://arxiv.org/abs/1312.4400">Network in Network</a></p><h3 id="fully-connected-layer-的缺点"><a href="#fully-connected-layer-的缺点" class="headerlink" title="fully connected layer 的缺点"></a>fully connected layer 的缺点</h3><p>在NIN论文中，提到全连接层参数多，容易陷入过拟合，降低了模型的泛化能力。</p><h3 id="Global-Average-Pooling"><a href="#Global-Average-Pooling" class="headerlink" title="Global Average Pooling"></a>Global Average Pooling</h3><p>既然全连接网络可以使feature map的维度减少，进而输入到<code>softmax</code>，但是又会造成过拟合，是不是可以用pooling来代替全连接。</p><p>NIN中提到的 GAP 的是将每一个feature map 得到一个分类的score。</p><p>答案是肯定的，Network in Network工作使用GAP来取代了最后的全连接层，直接实现了降维，更重要的是极大地减少了网络的参数(CNN网络中占比最大的参数其实后面的全连接层)。Global average pooling的结构如下图所示: <img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/global-average-pooling/1.JPG" alt="gap-structure"> </p><p>每个讲到全局池化的都会说<strong>GAP就是把<code>avg pooling</code>的窗口大小设置成<code>feature map</code>的大小</strong>，这虽然是正确的，但这并不是GAP内涵的全部。<strong>GAP的意义是对整个网络从结构上做正则化防止过拟合</strong>。既要参数少避免全连接带来的过拟合风险，又要能达到全连接一样的转换功能，怎么做呢？直接从feature map的通道上下手，如果我们最终有1000类，那么最后一层卷积输出的feature map就只有1000个channel，然后对这个feature map应用全局池化，输出长度为1000的向量，这就相当于<strong>剔除了全连接层黑箱子操作的特征，直接赋予了每个channel实际的类别意义。</strong></p><p>实验证明，这种方法是非常有效的，</p><p>这样做还有另外一个好处：不用在乎网络输入的图像尺寸。</p><p>同时需要注意的是，使用gap也有可能造成收敛变慢。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>inception 和Xception的结构其实也可以看作是NIN的一个结构</li><li>GAP 是一种减小参数的方式，可以获得全局的信息。</li><li></li></ol><p>ref:</p><ol><li><a href="http://blog.leanote.com/post/sunalbert/Global-average-pooling">http://blog.leanote.com/post/sunalbert/Global-average-pooling</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Product of Array Except Self 除本身之外的数组之积</title>
    <link href="/blog/2018/07/29/2019-03-08-Product%20of%20Array%20Except%20Self%20%E9%99%A4%E6%9C%AC%E8%BA%AB%E4%B9%8B%E5%A4%96%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%8B%E7%A7%AF/"/>
    <url>/blog/2018/07/29/2019-03-08-Product%20of%20Array%20Except%20Self%20%E9%99%A4%E6%9C%AC%E8%BA%AB%E4%B9%8B%E5%A4%96%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%8B%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Given an array of <em>n</em> integers where <em>n</em> &gt; 1, <code>nums</code>, return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>. </p><p>Solve it <strong>without division</strong> and in O(<em>n</em>).</p><p>For example, given <code>[1,2,3,4]</code>, return <code>[24,12,8,6]</code>.</p><p><strong>Follow up:</strong><br>Could you solve it with constant space complexity? (Note: The output array <strong>does not</strong> count as extra space for the purpose of space complexity analysis.)</p></blockquote><p>给定我们一个数组，让我们返回一个新数组，对于每一个位置上的数是其他位置上数的乘积，时间复杂度O(n)，并且不让我们用除法。</p><blockquote><p>先遍历一遍数组求出所有数字之积，然后除以对应位置的上的数字。(除法)</p></blockquote><p>解法：</p><script type="math/tex; mode=display">result_i = \Pi_{j=1}^{i-1}nums_j \times \Pi_{i+1}^{N}nums_j</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">productExceptSelf</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        result = [<span class="hljs-number">1</span>]*<span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            result[idx] = result[idx-<span class="hljs-number">1</span>]*nums[idx-<span class="hljs-number">1</span>]<br>        right = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            result[idx] = result[idx]*right<br>            right = right * nums[idx]<br>        <span class="hljs-keyword">return</span> result<br>        <br></code></pre></td></tr></table></figure><p>优化:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">productExceptSelf</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:</span><br>        result = [<span class="hljs-number">1</span>]*<span class="hljs-built_in">len</span>(nums)<br>        left = <span class="hljs-number">1</span><br>        right = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            result[idx] = result[idx] *left<br>            result[<span class="hljs-built_in">len</span>(nums)-idx-<span class="hljs-number">1</span>] = result[<span class="hljs-built_in">len</span>(nums)-idx-<span class="hljs-number">1</span>]*right<br>            left = left*nums[idx]<br>            right = right*nums[<span class="hljs-built_in">len</span>(nums)-idx-<span class="hljs-number">1</span>]<br>       <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2sum</title>
    <link href="/blog/2018/07/29/2018-07-29-%5B1%5D%202sum/"/>
    <url>/blog/2018/07/29/2018-07-29-%5B1%5D%202sum/</url>
    
    <content type="html"><![CDATA[<h1 id="2sum"><a href="#2sum" class="headerlink" title="2sum"></a>2sum</h1><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">Given</span> nums = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], target = <span class="hljs-number">9</span>,<br><br><span class="hljs-symbol">Because</span> nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span> + <span class="hljs-number">7</span> = <span class="hljs-number">9</span>,<br>return [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>].<br></code></pre></td></tr></table></figure><p>任务:给定一个数组，和一个目标的数值，给出相加可以得到目标数值的下标。</p><h2 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h2><p>复杂度$O(n^2)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>        <span class="hljs-keyword">if</span> nums[i]+nums[j]==target<br>        <span class="hljs-keyword">return</span> [i,j]<br></code></pre></td></tr></table></figure><h2 id="利用hash表"><a href="#利用hash表" class="headerlink" title="利用hash表"></a>利用hash表</h2><p>建立一个哈希表存储了数值和下标。复杂度可以为$O(n)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twosum_hashmap</span>(<span class="hljs-params">nums, target</span>):</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">input:</span><br><span class="hljs-string">nums- list of numbers to calc</span><br><span class="hljs-string">target - target value</span><br><span class="hljs-string">output:</span><br><span class="hljs-string">[a,b]- index of required numbers</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>dataset = &#123;&#125;<br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>dataset[(nums[index])] = index<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> nums:<br><span class="hljs-keyword">if</span> (target - value) <span class="hljs-keyword">in</span> dataset <span class="hljs-keyword">and</span> \<br>(value) <span class="hljs-keyword">in</span> dataset \<br><span class="hljs-keyword">and</span> dataset[(value)] != dataset[(target-value)]:<br><span class="hljs-keyword">return</span> [dataset[(value)], dataset[(target-value)]]<br><span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>one-pass </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twosum_hashmap_onepass</span>(<span class="hljs-params">nums,target</span>):</span><br>dataset=&#123;&#125;<br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br><span class="hljs-keyword">if</span> (target - nums[index]) <span class="hljs-keyword">in</span> dataset:<br><span class="hljs-keyword">return</span> [index, dataset[(target-nums[index])]]<br><span class="hljs-keyword">else</span>:<br>dataset[(nums[index])] = index<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.longest substring without repeating</title>
    <link href="/blog/2018/07/29/2018-07-29-3.%20Longest%20Substring%20Without%20Repeating%20Characters/"/>
    <url>/blog/2018/07/29/2018-07-29-3.%20Longest%20Substring%20Without%20Repeating%20Characters/</url>
    
    <content type="html"><![CDATA[<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Examples:</strong></p><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p><p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p><p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. Note that the answer must be a <strong>substring</strong>, <code>&quot;pwke&quot;</code> is a <em>subsequence</em> and not a substring.</p><p>最长不重复子串</p><h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><p>有一个判断当前字符串为不重复的函数 <code>boolean allUnique(String substring)</code> .</p><p>然后两重循环求解，时间复杂度$O(n^3)$</p><h2 id="sliding-window"><a href="#sliding-window" class="headerlink" title="sliding window"></a>sliding window</h2><p>在暴力搜索中， <code>boolean allUnique(String substring)</code> 对于字串是从头开始搜索的。如果使用<code>set</code>的结构，可以将复杂度降到$O(n^2)$</p><h2 id="Sliding-Window-Optimized"><a href="#Sliding-Window-Optimized" class="headerlink" title="Sliding Window Optimized"></a>Sliding Window Optimized</h2><p>暴力搜索会产生很多不必要的操作，比如$s<em>{i,j}​$代表字符串 $i​$ 到 $j-1​$ 没有重复字串。则我们只需要判断第 $j​$ 个是否含于 $s</em>{i, j}​$ 即可。如果不包含，则 $s<em>{i,j}​$ 变为 $s</em>{i,j+1}​$ 。如果包含，则从包含的下标的下一位置开始(记录对应的位置)。</p><p>如下图所示：</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/3.-Longest-Substring-Without-Repeating-Characters/1.jpg" alt=""></p><p>下一坐标起始点即为2</p><p>这样就把时间复杂度降到了$O(n)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s</span>):</span><br>  <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  :type s: str</span><br><span class="hljs-string">  :rtype: int</span><br><span class="hljs-string">  &quot;&quot;&quot;</span><br>  used = &#123;&#125;<br>  max_length = start = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>    <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> used <span class="hljs-keyword">and</span> start &lt;= used[c]:<br>      start = used[c] + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:   <br>      max_length = <span class="hljs-built_in">max</span>(max_length, i - start + <span class="hljs-number">1</span>)<br>          <br>    used[c] = i<br>  <br>  <span class="hljs-keyword">return</span> max_length<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.addTwoNumbers</title>
    <link href="/blog/2018/07/29/2018-07-29-2.%20add%202%20numbers/"/>
    <url>/blog/2018/07/29/2018-07-29-2.%20add%202%20numbers/</url>
    
    <content type="html"><![CDATA[<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: (<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)<br><span class="hljs-attribute">Output</span>: <span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span><br><span class="hljs-attribute">Explanation</span>: <span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span>.<br></code></pre></td></tr></table></figure><p><img src="https://leetcode.com/problems/add-two-numbers/Figures/2_add_two_numbers.svg" alt="Illustration of Adding two numbers"> </p><p>判断好进位和空数组，数组长度不一致的情形即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span>(<span class="hljs-params">self,l1,l2</span>):</span><br>result =[]<br>carry = <span class="hljs-literal">False</span><br>index = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-built_in">len</span>(l1) <span class="hljs-keyword">and</span> index &lt; <span class="hljs-built_in">len</span>(l2):<br>result.append((l1[index]+l2[index])%<span class="hljs-number">10</span>)<br><span class="hljs-keyword">if</span> carry:<br>result[-<span class="hljs-number">1</span>] = result[-<span class="hljs-number">1</span>] +<span class="hljs-number">1</span><br>carry = <span class="hljs-literal">False</span><br><span class="hljs-keyword">if</span> (l1[index]+l2[index]) &gt;= <span class="hljs-number">10</span>:<br>carry = <span class="hljs-literal">True</span><br>index = index + <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>: <br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(l1):<br><span class="hljs-keyword">if</span> carry:<br>tmp = <span class="hljs-number">1</span> +l1[index]<br>result.append(tmp%<span class="hljs-number">10</span>)<br><span class="hljs-keyword">if</span> tmp &gt;= <span class="hljs-number">10</span>:<br>index += <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>carry = <span class="hljs-literal">False</span><br>result+=(l1[index+<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span>:<br>result +=(l1[index:])<br><span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">while</span> index &lt; <span class="hljs-built_in">len</span>(l2):<br><span class="hljs-keyword">if</span> carry:<br>tmp = <span class="hljs-number">1</span> +l2[index]<br>result.append(tmp%<span class="hljs-number">10</span>)<br><span class="hljs-keyword">if</span> tmp &gt;= <span class="hljs-number">10</span>:<br>index += <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>carry = <span class="hljs-literal">False</span><br>result.append(l2[index+<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span>: <br>result +=(l2[index:])<br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span>(<span class="hljs-params">self, l1, l2</span>):</span><br>    <span class="hljs-keyword">if</span> l1 == <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> l2<br>    <span class="hljs-keyword">if</span> l2 == <span class="hljs-literal">None</span>: <span class="hljs-keyword">return</span> l1<br>    flag = <span class="hljs-number">0</span><br>    dummy = ListNode(<span class="hljs-number">0</span>); p = dummy<br>    <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:<br>        p.<span class="hljs-built_in">next</span> = ListNode((l1.val+l2.val+flag) % <span class="hljs-number">10</span>)<br>        flag = (l1.val+l2.val+flag) / <span class="hljs-number">10</span><br>        l1 = l1.<span class="hljs-built_in">next</span>; l2 = l2.<span class="hljs-built_in">next</span>; p = p.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">if</span> l2:<br>        <span class="hljs-keyword">while</span> l2:<br>            p.<span class="hljs-built_in">next</span> = ListNode((l2.val+flag) % <span class="hljs-number">10</span>)<br>            flag = (l2.val+flag) / <span class="hljs-number">10</span><br>            l2 = l2.<span class="hljs-built_in">next</span>; p = p.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">if</span> l1:<br>        <span class="hljs-keyword">while</span> l1:<br>            p.<span class="hljs-built_in">next</span> = ListNode((l1.val+flag) % <span class="hljs-number">10</span>)<br>            flag = (l1.val+flag) / <span class="hljs-number">10</span><br>            l1 = l1.<span class="hljs-built_in">next</span>; p = p.<span class="hljs-built_in">next</span><br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>: p.<span class="hljs-built_in">next</span> = ListNode(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>93. Restore IP Address</title>
    <link href="/blog/2018/07/28/2018-07-28-93%20.%20Restore%20IP%20Addresses/"/>
    <url>/blog/2018/07/28/2018-07-28-93%20.%20Restore%20IP%20Addresses/</url>
    
    <content type="html"><![CDATA[<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p><p><strong>Example:</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Input:</span> <span class="hljs-string">&quot;25525511135&quot;</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;255.255.11.135&quot;</span>, <span class="hljs-string">&quot;255.255.111.35&quot;</span>]<br></code></pre></td></tr></table></figure><p>给定一个字符串，输出所有可能的IP地址</p><h2 id="四分法"><a href="#四分法" class="headerlink" title="四分法"></a>四分法</h2><blockquote><p>三个点将字符串分成四段，验证每一段是否是有效的。我们只要控制这三个分割点就行了，注意约束条件有两个，一个是一段字符串不超过3个字母，另一个是控制好每段字符串最远结束的位置，比如第一个字符串最多延伸到倒数第4个字母</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restoreIpAddresses</span>(<span class="hljs-params">s, res</span>):</span><br>    res = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,i+<span class="hljs-number">4</span>):<br>            <span class="hljs-keyword">if</span> j &gt;= <span class="hljs-built_in">len</span>(s):<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j, j+<span class="hljs-number">4</span>):<br>                <span class="hljs-keyword">if</span> k &gt;= <span class="hljs-built_in">len</span>(s):<br>                    <span class="hljs-keyword">break</span><br>                s1 = s[<span class="hljs-number">0</span>:i]<br>                s2 = s[i:j]<br>                s3 = s[j:k]<br>                s4 = s[k:]<br>                <span class="hljs-keyword">if</span> isValid(s1) <span class="hljs-keyword">and</span> isValid(s2) <span class="hljs-keyword">and</span> isVAlid(s3) <span class="hljs-keyword">and</span> isValid(s4):<br>                    res.append(s1+<span class="hljs-string">&#x27;.&#x27;</span>+s2+<span class="hljs-string">&#x27;.&#x27;</span>+s3+<span class="hljs-string">&#x27;.&#x27;</span>+s4)<br>     <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="递归求解"><a href="#递归求解" class="headerlink" title="递归求解"></a>递归求解</h2><blockquote><p>因为<code>ip</code>地址为4段，每段数值在<code>0-255</code>之间。从头开始，判断。只要满足每段在此范围内，即可进入下一段的操作。如果最后一段以后，长度为<code>0</code>。则此答案为正确答案。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">restoreIpAddresses</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># split the string into 4 part</span><br>        res = []<br>        self.getip(s, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;&quot;</span>, res)<br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getip</span>(<span class="hljs-params">self, s, k, out, result</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        s ： input str</span><br><span class="hljs-string">        out : result str</span><br><span class="hljs-string">        result : all possible result</span><br><span class="hljs-string">        k      : k-th part</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>                result.append(out)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 0-3 每段最长3</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                <span class="hljs-comment"># len(s) &gt;= i 保证足够分的</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &gt;= i <span class="hljs-keyword">and</span> self._isValid(s[<span class="hljs-number">0</span>:i]):<br>                    <span class="hljs-comment"># k==1 即最后一段了</span><br>                    <span class="hljs-keyword">if</span> k == <span class="hljs-number">1</span>:<br>                        self.getip(s[i:], k-<span class="hljs-number">1</span>, out+s[<span class="hljs-number">0</span>:i], result)<br>                    <span class="hljs-keyword">else</span>:<br>                        self.getip(s[i:], k-<span class="hljs-number">1</span>, out+s[<span class="hljs-number">0</span>:i]+<span class="hljs-string">&#x27;.&#x27;</span>, result)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_isValid</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(s) &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> (<span class="hljs-built_in">len</span>(s)&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[<span class="hljs-number">0</span>] ==<span class="hljs-string">&#x27;0&#x27;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &lt;= <span class="hljs-built_in">int</span>(s) &lt;= <span class="hljs-number">255</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learning to Adapt Structured Output Space for Semantic Segmentation</title>
    <link href="/blog/2018/07/22/2018-07-22-Adapt%20SegNet/"/>
    <url>/blog/2018/07/22/2018-07-22-Adapt%20SegNet/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/wasidennis/AdaptSegNet">github code</a></p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/Adapt-SegNet/1.jpg" alt="adapted SegNet">.png)</p><p>网络结构：</p><p>一个segmentation 作为G，还有一个Discriminator分辨feature map来自于哪个域（多尺度）。</p><p><strong>loss function</strong></p><script type="math/tex; mode=display">L(I_s, I_t) = L_{seg}(I_s) + λ_{adv}L_{adv}(I_t),</script><p>这里的$L<em>{seg}$用的是从cross-entropy, $L</em>{adv}$是adversarial loss。</p><h2 id="Output-Space-Adaptation"><a href="#Output-Space-Adaptation" class="headerlink" title="Output Space Adaptation"></a>Output Space Adaptation</h2><p>使用的low-dimensional soft-max output. 作者提到的是，对于segmentation，high layer 存有的是语义信息，（在image-classification 任务中，使用高层信息迁移是足够的）但是<strong>在segmentation 中，使用的不仅仅是语义信息，还有局部的相关性，语义信息等</strong>。<strong>作者认为无论图像来自哪个域，学习到的特征是具有相似性的。局部信息和全局信息都应该是具有相似性的。</strong></p><h3 id="Single-level-Adversarial-Learning"><a href="#Single-level-Adversarial-Learning" class="headerlink" title="Single-level Adversarial Learning"></a>Single-level Adversarial Learning</h3><p><strong>Discriminator Training</strong> </p><script type="math/tex; mode=display">\mathcal{L}_d(P ) = − \sum_{h,w}(1 − z) \log(D(P )^{(h,w,0)}) +z\log(D(P )^{(h,w,1)})</script><p>这里是用cross-entropy 进行的二分类。</p><p><strong>Segmentation Network Training</strong></p><p><strong><em>source domain</em></strong></p><script type="math/tex; mode=display">\mathcal{L}_{seg}(I_s) = −\sum_{h,w}\sum_{c\in C}Y_s^{(h,w,c)}\log(P_s^{(h,w,c)})</script><p> $Y_s$ is the ground truth annotations for source images and $P_s = G(I_s)$ is the segmentation output.</p><p> <strong><em>target domain</em></strong> </p><script type="math/tex; mode=display">\mathcal{L}_{adv}(I_t) = −\sum_{h,w}\log(D(P_t)^{(h,w,1)})</script><p>通过将target predication 认为 source predication， 最大化这个概率，可以达到欺骗 Discriminator的目的。</p><h3 id="Multi-level-Adversarial-Learning"><a href="#Multi-level-Adversarial-Learning" class="headerlink" title="Multi-level Adversarial Learning"></a>Multi-level Adversarial Learning</h3><p>此时考虑不同的层的信息</p><script type="math/tex; mode=display">\mathcal{L}(I_s, I_t) = \sum_i λ^i_{seg}\mathcal{L}^i_{seg}(I_s) + \sum_i λ^i_{adv}\mathcal{L}^i_{adv}(I_t),</script><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p><strong>Discriminator</strong></p><p>5个卷积层，卷积核大小$4*4$，步长为2. 卷积核个数依次为$[64,128,256,512,1]$。激活函数为 leaky ReLU （0.2）.最后一层有一个Upsample层，将大小缩放到与输入一样大小。</p><p><strong>Segmentation Network</strong></p><ul><li>DeepLab-v2 framework with ResNet-101 [11] model pre-trained on ImageNet</li><li>Remove the last classiﬁcation layer and modify the stride of the last two convolution layers from 2 to 1, making the resolution of the output feature maps effectively 1/8 times the input image size.</li><li>To enlarge the receptive ﬁeld, we apply dilated convolution layers in conv4 and conv5 layers with a stride of 2 and 4, respectively. </li><li>After the last layer, we use the Atrous Spatial Pyramid Pooling (ASPP) [2] as the ﬁnal classiﬁer.</li><li>Finally, we apply an up-sampling layer along with the softmax output to match the size of the input<br>image.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fully Convolutional Adaptation Networks for Semantic Segmentation</title>
    <link href="/blog/2018/07/20/2018-07-20-FCAN/"/>
    <url>/blog/2018/07/20/2018-07-20-FCAN/</url>
    
    <content type="html"><![CDATA[<p>作者提出了一种 分割迁移网络（FCAN）可以在渲染图和真实图像之间进行图像分割迁移。<a href="https://arxiv.org/abs/1804.08286">论文地址</a></p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/FCAN/1.jpg" alt=""></p><p>解决的问题在于从仿真图像的训练模型如何迁移到真实场景下，在此基础上如何利用源域监督信息和大量的无标签的真实图像，来完成模型迁移的任务。</p><h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/FCAN/2.jpg" alt=""></p><p>模型结构基本如图所示。主要分为Appearance Adaptation Networks（AAN），和Representation Adaptation Network（RAN）。前者做的事完成输入图像的域转换，源域图像和目标域图像的风格转换。后者是用来学习与域无关的图像分割特征。</p><h2 id="AAN"><a href="#AAN" class="headerlink" title="AAN"></a>AAN</h2><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/FCAN/3.jpg" alt=""></p><p>AAN目的在于使得来自源域的图像看起来像是来自于目标域。对于AAN，对于来自源域的一张图片$x_s$和来自目标域的一堆图片$\mathcal{X}_t$。输入为白噪声，将$x_s$迭代渲染成为目标域风格。（或者说将$x_s$的内容和来自$\mathcal{X}_t$的风格结合起来）</p><blockquote><p>这里的insight是对于一个网络，前几层学到的是low-level的style信息，越靠后学到的high-level的寓意信息。</p></blockquote><p>假设第 $l$ 层的feature map 有 $N_l$ 个 ， 每个 channel 的长宽均为 $H_l*W_l$, 则 $l$ 层的 feature map 可以表示为$M^L \in \mathcal{R}^{N_l \times H_l \times W_l}$ </p><p><strong>content loss</strong></p><script type="math/tex; mode=display">\min_{x_o}\sum_{l\in L}w_s^l Dist(M_o^l, M_s^l)</script><p>其中 $w_s^l$ 是不同层的权重， $Dist()$ 距离采用的是欧氏距离。</p><p><strong>style loss</strong></p><p>style 这里选用的是neural style transfer中的度量， 计算不同feature map上的gram矩阵。</p><script type="math/tex; mode=display">G^{l,ij}=<M^{l,i}, M^{l,j}></script><p>这里 $M^{l,i}$$M^{l,j}$  是第$l$层的第$i，j$个向量化以后的feature map，然后进行内积运算。 在论文中，目标域的为多张图片（target image pool）的均值，记为$\bar{G}_t^l$ </p><p>loss 即为</p><script type="math/tex; mode=display">\min_{x_o}\sum_{l\in L}w_t^l Dist(G_o^l, \bar{G}_t^l)</script><p>AAN总的loss为</p><script type="math/tex; mode=display">\mathcal{L}_{AAN}(x_o)=\sum_{l\in L}w_s^l Dist(M_o^l, M_s^l)+\alpha\sum_{l\in L}w_t^lDist(G_o^l,\bar{G}_t^l)</script><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ul><li><p>在论文的实验中采用的是<code>ResNet50</code>作为基本的CNN的结构。并且使用的是$L={conv1, res2c, res3d, res4f,res5c}$作为风格特征提取输入。</p></li><li><p>$w_s^l$和$w_t^l$ 是根据图像设置的？</p></li><li><p>$\alpha=10^{-14}$</p></li><li><p>迭代渲染次数1000</p></li><li><p>在每次迭代过程中$i$</p><p>image $x_o$是迭代渲染的，</p><script type="math/tex; mode=display">x_o^i=x_o^{i-1}-w^{i-1}\frac{g^{i-1}}{\Vert g^{i-1}\Vert_1}</script><script type="math/tex; mode=display">g^{i-1}=\frac{\partial \mathcal{L}_{ANN}(x_o^{i-1})}{\partial x_o^{i-1}}</script></li></ul><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/FCAN/4.jpg" alt=""></p><h2 id="RAN"><a href="#RAN" class="headerlink" title="RAN"></a>RAN</h2>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>normalization layer</title>
    <link href="/blog/2018/07/18/2018-07-18-activation%20normalization%20layer/"/>
    <url>/blog/2018/07/18/2018-07-18-activation%20normalization%20layer/</url>
    
    <content type="html"><![CDATA[<h1 id="BN及其变体"><a href="#BN及其变体" class="headerlink" title="BN及其变体"></a>BN及其变体</h1><h2 id="BN"><a href="#BN" class="headerlink" title="BN"></a>BN</h2><p>解决的问题：</p><ol><li><p>Internal Covariate Shift</p><blockquote><p><strong>Internal Covariate Shift 与 Covariate Shift</strong></p><p>是对层与层之间数值偏移的描述，<code>batchnorm</code>对数值层面做了<strong>高斯均衡化</strong>，而后者是迁移学习中解决原空间和目标空间边缘分布不一致的一个分支问题，是对不同空间表征的偏移的描述。</p><p><strong>Internal Covariate Shift</strong></p><p>影响在于训练过程中，参数空间变化使得学习的分布也是在变化的。这就增大了学习的难度。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/activation-normalization-layer/1.jpg" alt="Internal Covariate Shift"></p><p>举个简单线性分类栗子，假设我们的数据分布如a所示，参数初始化一般是0均值，和较小的方差，此时拟合的$y=wx+b$如<code>b</code>图中的橘色线，经过多次迭代后，达到紫色线，此时具有很好的分类效果，但是如果我们将其归一化到0点附近，显然会加快训练速度，如此我们更进一步的通过变换拉大数据之间的相对差异性，那么就更容易区分了。</p><p>注：另一个原因在于，训练过程对于后一层来说，前一层的数据分布也是在变化的。更增大了训练的难度。</p><p><strong>Covariate Shift</strong></p><p>指的是，数据集之间的分布差异。（Domain shift）</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/activation-normalization-layer/2.jpg" alt="domain shift"></p></blockquote></li></ol><ol><li><p>算法流程：</p><blockquote><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/activation-normalization-layer/3.jpg" alt="BN_forward"></p></blockquote></li><li><p>解释</p><ol><li><blockquote><p>从Bayesian的角度去解释<code>batchnorm</code>，首先引出<code>PRML</code>中解释的L2-NORM的由来：</p><p>【似然函数*先验分布=后验分布，log(后验分布)=log(似然函数)+L2-NORM】，</p><p>可知在<code>log</code>域的<code>L2-NORM</code>（即先验分布）对应原值域的高斯分布，因此目标函数的拟合相当于后验分布的拟合，对weight的L2-NORM 正则项是对weight先验分布的拟合，这种拟合压制了训练中<code>weight</code>的波动，而原值域的变化不仅依赖于weight，也依赖于输入<code>X</code>，因此<code>batchnorm</code>就是一种对<code>X</code>波动的压制，从这个意义上，<code>batchnorm</code>便可解释为对<code>X</code>的正则项。这种压制其实并不是刚刚出现的，所谓白化操作就是对输入数据的<code>normalize</code>，而<code>batchnorm</code>简化了其计算。</p></blockquote></li><li><blockquote><p>作者猜测<code>BatchNormalization</code>层的雅可比矩阵的奇异值接近1，这加速了模型的收敛速度。</p></blockquote></li><li><blockquote><p>而scale与shift也对应着Bayesian解释，由于采用部分数据的分布作为所有数据的先验分布，其实便破坏了整个空间的原始表征，scale与shift就是在逆转对表征的破坏，逆转的程度由模型在训练中自己调整。通常将带scale和shift的BN层加在非线性激活函数之前，在<code>caffe</code>的官方版本中将bias转移到了<code>batchnorm</code>后面的scale层中。    </p></blockquote></li></ol></li><li><p>缺点</p><blockquote><p>对mini-batch求统计信息，因此具有数据依赖性，数据的随机性会导致训练的不稳定，且batch=1时无法使用。而各种变体本质上就是在寻找Natural Gradient，在加速收敛的同时，保证模型的泛化能力。</p></blockquote></li></ol><h2 id="Batch-Renormalization"><a href="#Batch-Renormalization" class="headerlink" title="Batch-Renormalization"></a>Batch-Renormalization</h2><ol><li><p>问题</p><p>batch norm原作者对其的优化，该方法保证了train和inference阶段的等效性，解决了非独立同分布和小minibatch的问题</p></li><li><p>算法</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/activation-normalization-layer/4.jpg" alt="Batch-Renormalization"></p><p><code>r</code>和<code>d</code>首先通过minibatch计算出，但stop_gradient使得<strong>反传中<code>r</code>和<code>d</code>不被更新</strong>，因此r和d不被当做训练参数对待。试想如果r和d作为参数来更新，如下式所示：</p><script type="math/tex; mode=display">\frac{x_{i}-\mu}{\sigma}=\frac{x_{i}-\mu_{\mathcal{B}}}{\sigma_{\mathcal{B}}} \cdot r+d, \text { where } r=\frac{\sigma_{\mathcal{B}}}{\sigma}, d=\frac{\mu_{\mathcal{B}}-\mu}{\sigma}</script></li></ol><p>   这样一来，就相当于在训练阶段也使用<code>moving averages</code>  $μ$和$σ$，这会引起梯度优化和normalization之间的冲突，优化的目的是通过对权重的scale和shift去适应一个minibatch，normalization则会抵消这种影响，<br>   而moving averages则消除了归一化后的激活对当前minibatch的依赖性，使得minibatch丧失了对每次权重更新方向的调整，从而使得权重尺度因normalization的抵消而无边界的增加却不会降低loss。而在前传中r和d的仿射变换修正了minibatch和普适样本的差异，使得该层的激活在inference阶段能得到更有泛化性的修正。</p><ol><li><h2 id="Weight-Normalization"><a href="#Weight-Normalization" class="headerlink" title="Weight-Normalization"></a>Weight-Normalization</h2></li></ol><h2 id="Layer-Norm"><a href="#Layer-Norm" class="headerlink" title="Layer Norm"></a>Layer Norm</h2><h2 id="Group-Norm"><a href="#Group-Norm" class="headerlink" title="Group Norm"></a>Group Norm</h2><h2 id="Instance-Norm"><a href="#Instance-Norm" class="headerlink" title="Instance Norm"></a>Instance Norm</h2><p>计算</p><script type="math/tex; mode=display">IN(x)=\gamma (\frac{x-\mu(x)}{\sigma(x)}+\beta)</script><p>其中</p><script type="math/tex; mode=display">\mu_{nc}(x)=\frac{1}{HW}\sum\sum(x_{nchw})</script><script type="math/tex; mode=display">\sigma_{nc}(x)=\sqrt{\frac{1}{HW}\sum\sum(x_{nchw}-\mu_{nc}(x))^2+\epsilon}</script><h2 id="Ada-BN"><a href="#Ada-BN" class="headerlink" title="Ada-BN"></a>Ada-BN</h2><p>Ada-BN提出是为了解决域适应问题（Domain Adaption）问题。作者统计发现，对于源域的数据，通过BN层以后，可以达到很好的白化效果，但是由于目标和源域之间的分布差异，源域的BN层的统计值并不适应于目标域，因此可以通过替换源域模型的参数目标域参数的方法来进行域适应。</p><h2 id="Ada-IN"><a href="#Ada-IN" class="headerlink" title="Ada-IN"></a>Ada-IN</h2><h2 id="IBN"><a href="#IBN" class="headerlink" title="IBN"></a>IBN</h2><p>IBN-net 是将<code>resnet</code>中的BN替换成BN和IN。</p><p>ref:[<a href="https://zhuanlan.zhihu.com/p/33173246">https://zhuanlan.zhihu.com/p/33173246</a>]</p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>loss function</title>
    <link href="/blog/2018/07/17/2018-07-17-loss%20function/"/>
    <url>/blog/2018/07/17/2018-07-17-loss%20function/</url>
    
    <content type="html"><![CDATA[<p>损失函数（loss function）是用来估量你模型的预测值f(x)与真实值Y的不一致程度，它是一个非负实值函数,通常使用$L(Y, f(x))$来表示，损失函数越小，模型的鲁棒性就越好。损失函数是<strong>经验风险函数</strong>的核心部分，也是<strong>结构风险函数</strong>重要组成部分。模型的结构风险函数包括了经验风险项和正则项，通常可以表示成如下式子：</p><script type="math/tex; mode=display">θ^∗=\arg \min_{θ} \frac{1}{N}∑_{i=1}^N L(y_i,f(x_i;θ))+λ Φ(θ)</script><p>其中，前面的均值函数表示的是经验风险函数，$L$代表的是损失函数，后面的$Φ$是正则化项（regularizer）或者叫惩罚项（penalty term），它可以是L1，也可以是L2，或者其他的正则函数。整个式子表示的意思是<strong>找到使目标函数最小时的$θ$值</strong>。下面主要列出几种常见的损失函数。</p><h2 id="logistic-loss-function"><a href="#logistic-loss-function" class="headerlink" title="logistic loss function"></a>logistic loss function</h2><p>针对二分类而言,</p><script type="math/tex; mode=display">J(θ)=−\frac{1}{m}∑_{i=1}^m[y(i)\log h_θ(x^{(i)})+(1−y^{(i)})\log(1−h_θ(x^{(i)}))]</script><h2 id="Cross-Entropy-交叉熵"><a href="#Cross-Entropy-交叉熵" class="headerlink" title="Cross Entropy(交叉熵)"></a>Cross Entropy(交叉熵)</h2><p>交叉熵越小，就证明算法所产生的策略越接近最优策略，也就间接证明我们的算法所计算出的非真实分布越接近真实分布</p><p> 交叉熵损失函数从信息论的角度来说，其实来自于KL散度，只不过最后推导的新式等价于交叉熵的计算公式：</p><script type="math/tex; mode=display">H(p,q)=−\sum_{k=1}^N(p_k∗\log q_k) H(p,q)=−\sum_{k=1}^N(p_k∗\log q_k)</script><p><strong>最大似然估计、Negative Log Liklihood(NLL)、KL散度与Cross Entropy其实是等价的</strong>，都可以进行互相推导，当然MSE也可以用Cross Entropy进行对到出（详见Deep Learning Book P132）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CYCADA CYCLE-CONSISTENT ADVERSARIAL DOMAIN ADAPTATION</title>
    <link href="/blog/2018/07/16/2018-07-16-CYCADA/"/>
    <url>/blog/2018/07/16/2018-07-16-CYCADA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jhoffman/cycada_release">github code</a></p><p><code>CyCADA</code>论文中，定义了一种问题——无监督适配，即仅提供源数据 $X_S$ 和源标签 $Y_S$，以及源域目标数据$X_T$，没有目标标签或者不利用它。问题的目的是学习一个模型 $f$，它可以正确预测目标数据的标签。 </p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/CYCADA/1.jpg" alt="CYCADA"></p><p><code>CYCADA</code> 的模型基本如上图所示，论文的主要思路来自于<code>cycleGAN</code>, 利用<code>cycle GAN</code>来完成image-level的适配问题。通过讲图像变换到目标域来实现域适配的问题。</p><p>源域训练模型的loss函数</p><p><img src="http://ww1.sinaimg.cn/mw690/007arC1sly1g0whdz9yqtj30n802ywen.jpg" alt="src_loss"></p><p>其中$\sigma$ 是<code>softmax</code></p><p>在论文中，加入语义一致性（semantic consistency）是一个贡献，因为已知源标签。语义损失为： </p><script type="math/tex; mode=display">L_{sem}(G_{S \rightarrow T}， G_{T \rightarrow S}, X_S, X_T, f_S) = L_{task}(f_S, G_{T \rightarrow S}(X_T), p(f_S, X_T)) + L_{task}(f_S, G_{S \rightarrow T}(X_S), p(f_S, X_S))</script><p>损失函数如下：</p><script type="math/tex; mode=display">\begin{aligned}& L_{CyCADA}(f_T, ,X_S, X_T, Y_S, G_{S \rightarrow T}, G_{T \rightarrow S}, D_S, D_T) \\&= L_{task}(f_T, G_{S \rightarrow T}(X_S), Y_S)\\&+ L_{GAN}(G_{S \rightarrow T}, D_T, X_T, X_S) \\&+ L_{GAN}(G_{T \rightarrow S}, D_S, X_S, X_T)\\& + L_{GAN}(f_T, D_{feat}, f_S(G_{S \rightarrow T}(X_S)), X_T)\\& + L_{cyc}(G_{S \rightarrow T}, G_{T \rightarrow S}, X_S, X_T)\\& + L_{sem}(G_{S \rightarrow T}, G_{T \rightarrow S}, X_S, X_T, f_S)\end{aligned}</script><p>第一项 $L<em>{task}(f_T,G_S→T(X_S),Y_S)$ 表示，源图像 $X_S$ 经过变换（全卷积网络？）$G_S→T$ 伪目标图像， 然后该图像经过分割网络得到源预测结果，与源标签$Y_S$ 得到$L</em>{task}$ 损失；</p><p>第二项$L_{GAN}(G_S→T,D_T,X_T,X_S)$ 表示，变换 $G_S→T$ 根据源图像$X_S$ 生成伪目标图像去fool对抗判别器 $D_T$， 并且该判别器尝试从源目标数据（source target data）（生成？）中识别出真实目标数据（real target data）。 </p><p><img src="http://ww1.sinaimg.cn/large/007arC1sly1g0wheejup4j30rr01i3yn.jpg" alt=""></p><p>第三项类似于第二项，然后就是<code>CyCleGAN</code>的思路。</p><p>第四项为特征水平的GAN损失，如图1中橙色部分。</p><p>第五项为<code>CyCleGAN</code>中的重建损失。第六项为语义一致性，如图1中黑色部分。  </p>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++调用tensorflow模型</title>
    <link href="/blog/2018/07/02/2018-07-02-C++%E8%B0%83%E7%94%A8tensorflow%E6%A8%A1%E5%9E%8B/"/>
    <url>/blog/2018/07/02/2018-07-02-C++%E8%B0%83%E7%94%A8tensorflow%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong>C++ 和python的混合编程</strong></p><ul><li><p>windows + vs</p><ol><li><p>新建一个工程，在工程属性中添加如下的几个</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/C%2B%2B%E8%B0%83%E7%94%A8tensorflow%E6%A8%A1%E5%9E%8B/1.jpg" alt=""></p><blockquote><p>C:\Users\[user_name]\Anaconda3\include</p><p>C:\Users\[user_name]\Anaconda3\Lib</p><p>C:\Users\[user_name]\Anaconda3\libs</p></blockquote><p>具体路径根据自己python的安装情况确定。</p></li><li><p>添加附加依赖项 <code>pytyhon36.lib</code>,具体参照自己的文件路径以及python版本</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/C%2B%2B%E8%B0%83%E7%94%A8tensorflow%E6%A8%A1%E5%9E%8B/2.jpg" alt=""></p></li><li><p>如果需要在<code>DEBUG</code>下运行，需要修改<code>pyconfig.h</code>文件，我的电脑上的位置为<code>C:\Users\chmtt\Anaconda3\include\pyconfig.h</code> 打开以后在293行，将<code>python36_d.lib</code>修改为<code>python36.lib</code> 即可。如果直接在<code>release</code>下运行无需操作。</p></li><li><p>假设需要调用的<code>python</code>脚本为</p><p>默认你已经写好<code>tensorflow</code>的<code>python</code>脚本，并能跑成功。（<code>tensorflow</code>的使用不是本文重点）<br>c++需要调用的就是这个<code>classify.py</code>里面的<code>evaluate</code>函数，传入图片路径，返回分类结果给c++程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evaluate</span>(<span class="hljs-params">pic</span>):</span><br>    image = Image.<span class="hljs-built_in">open</span>(pic)<br>    image = image.resize([<span class="hljs-number">256</span>, <span class="hljs-number">256</span>])<br>    image_array = np.array(image)<br>    <span class="hljs-keyword">with</span> tf.Graph().as_default():<br>        <span class="hljs-comment">#里面就是对图像读取模型，预测，得到prediction……</span><br>            max_index = np.argmax(prediction)<br>            <span class="hljs-keyword">return</span> max_index<br></code></pre></td></tr></table></figure></li><li><p>C++Demo</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Python.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* picpath =<span class="hljs-string">&quot;/home/pdd/PD/c++/c++python/pic/0.0.jpg&quot;</span>;<br>    <span class="hljs-built_in">Py_Initialize</span>(); <br>        <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">Py_IsInitialized</span>() ) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>        &#125;  <br>        <span class="hljs-built_in">PyRun_SimpleString</span>(<span class="hljs-string">&quot;import sys&quot;</span>);<br>        <span class="hljs-built_in">PyRun_SimpleString</span>(<span class="hljs-string">&quot;sys.path.append(&#x27;./&#x27;)&quot;</span>);<br>    PyObject* pMod = <span class="hljs-literal">NULL</span>;<br>    PyObject* pFunc = <span class="hljs-literal">NULL</span>;<br>    PyObject* pParm = <span class="hljs-literal">NULL</span>;<br>    PyObject* pRetVal = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">int</span> iRetVal = <span class="hljs-number">-999</span>;<br>    <span class="hljs-keyword">const</span>  <span class="hljs-keyword">char</span>* modulName=<span class="hljs-string">&quot;classify&quot;</span>;    <span class="hljs-comment">//这个是被调用的py文件模块名字</span><br>    pMod = <span class="hljs-built_in">PyImport_ImportModule</span>(modulName); <br>    <span class="hljs-keyword">if</span>(!pMod)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* funcName=<span class="hljs-string">&quot;evaluate&quot;</span>;  <span class="hljs-comment">//这是此py文件模块中被调用的函数名字</span><br>    pFunc = <span class="hljs-built_in">PyObject_GetAttrString</span>(pMod, funcName); <br>    <span class="hljs-keyword">if</span>(!pFunc)  <br>    &#123;   <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;  <br>    &#125;  <br>    pParm = <span class="hljs-built_in">PyTuple_New</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">PyTuple_SetItem</span>(pParm, <span class="hljs-number">0</span>, <span class="hljs-built_in">Py_BuildValue</span>(<span class="hljs-string">&quot;s&quot;</span>,picpath));<span class="hljs-comment">//传入的参数，是图片的路径</span><br>    pRetVal = <span class="hljs-built_in">PyEval_CallObject</span>(pFunc, pParm);<span class="hljs-comment">//这里开始执行py脚本</span><br>    <span class="hljs-built_in">PyArg_Parse</span>(pRetVal, <span class="hljs-string">&quot;i&quot;</span>, &amp;iRetVal);<span class="hljs-comment">//py脚本返回值给iRetVal</span><br>    <span class="hljs-comment">//PyErr_Print();</span><br>    std::cout&lt;&lt;iRetVal;<br>    <span class="hljs-keyword">return</span> iRetVal;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>ubuntu </p><p>安装了<code>anaconda</code>, <code>tensorflow</code></p><p>C++ 和 python代码与上面类似。在构建执行文件时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">main:c++python.cpp<br>    g++ -o out c++python.cpp -I/home/pdd/anaconda3/include/python3.6m -lpython3.6m -L /home/pdd/anaconda3/lib<br><br>clean:<br>    rm -rf *.o <br></code></pre></td></tr></table></figure><p><code>-I</code>后面的<code>/home/pdd/anaconda3/include/python3.6m</code>有需要的<code>Python.h</code>；</p><p><code>-lpython3.6m</code>链接到需要的<code>libpython3.6m.so</code>;</p><p><code>-L</code>指出链接的路径。  </p><p>终端输入make。如果提示需要什么<code>libpython3.6m.so</code>,就把<code>/home/pdd/anaconda3/lib</code>下的<code>libpython3.6m.*.so</code>复制到<code>/usr/lib/</code>下（<code>sudo cp ——–</code>）  此时再次输入make，一切ok！得到out文件，输入./out </p></li></ul></li><li><p>源码编译运行。</p><p>大体的流程如下：</p><ul><li>1.使用<code>tensorflow python API</code>编写和训练自己的模型，训练完成后，使用<code>tensorflow saver</code>将模型保存下来。</li><li>2.使用<code>tensorflow c++ API</code> 构建新的<code>session</code>，读取<code>python</code>版本保存的模型，然后使用<code>session-&gt;run()</code>获得模型的输出。</li><li>3.编译和运行基于<code>tensorflow c++  API</code>写的代码。</li></ul><ol><li><strong>Ubuntu</strong></li><li><strong>windows</strong></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>tensorflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高效numpy指北</title>
    <link href="/blog/2018/06/27/2018-06-27-numpy%E6%8C%87%E5%8C%97/"/>
    <url>/blog/2018/06/27/2018-06-27-numpy%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<h1 id="高效numpy指北"><a href="#高效numpy指北" class="headerlink" title="高效numpy指北"></a>高效<code>numpy</code>指北</h1><p>ref:<a href="https://speakerdeck.com/cournape/using-numpy-efficiently?slide=19">link</a></p><h2 id="why-numpy"><a href="#why-numpy" class="headerlink" title="why numpy"></a>why <code>numpy</code></h2><ul><li>运算高效</li></ul><h2 id="numpy-内存结构"><a href="#numpy-内存结构" class="headerlink" title="numpy 内存结构"></a><code>numpy</code> 内存结构</h2><ul><li>一块内存区域</li><li><code>dtype</code> 确定了内存区域数据类型</li><li><code>metadata</code> 比如 <code>shape</code>、<code>strides</code> etc</li></ul><p>注：<code>numpy</code> 内存占用和 <code>C</code> 基本相同，多了常数内存消耗</p><h2 id="numpy-广播机制"><a href="#numpy-广播机制" class="headerlink" title="numpy 广播机制"></a><code>numpy</code> 广播机制</h2><p>自动将常数变为可以参与运算的形式</p><ul><li>无需对常数变成可以进行运算的大小（自动）</li></ul><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/numpy%E6%8C%87%E5%8C%97/1.jpg" alt=""></p><p><strong>注意：</strong></p><ul><li>广播机制是逻辑上的参与运算，并没有创建相应的矩阵（向量）</li></ul><h2 id="indexing"><a href="#indexing" class="headerlink" title="indexing"></a>indexing</h2><h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><p><code>[::k]</code> <code>k</code> 是步长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">x=[[0,1,2],</span><br><span class="hljs-string">   [3,4,5]]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>x[:,::<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">[[0, 2],</span><br><span class="hljs-string"> [3, 5]]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>x[::<span class="hljs-number">2</span>,::<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">array([[0, 2]])</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>x[:,::-<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">array([[2, 1, 0],</span><br><span class="hljs-string">       [5, 4, 3]])</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>x[::-<span class="hljs-number">1</span>,::-<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">array([[5, 4, 3],</span><br><span class="hljs-string">       [2, 1, 0]])</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br></code></pre></td></tr></table></figure><p> 简单的index 返回的是原数组的一个view，而非copy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">x[::-<span class="hljs-number">1</span>,::-<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">array([[5, 4, 3],</span><br><span class="hljs-string">       [2, 1, 0]])</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x[::-<span class="hljs-number">1</span>,::-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">120</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br>array([[  <span class="hljs-number">0</span>, <span class="hljs-number">120</span>,   <span class="hljs-number">2</span>],<br>       [  <span class="hljs-number">3</span>,   <span class="hljs-number">4</span>,   <span class="hljs-number">5</span>]])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>c =x[::-<span class="hljs-number">1</span>,::-<span class="hljs-number">1</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">123</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br>array([[  <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">2</span>],<br>       [  <span class="hljs-number">3</span>,   <span class="hljs-number">4</span>, <span class="hljs-number">123</span>]])<br></code></pre></td></tr></table></figure><h3 id="fancy-indexing"><a href="#fancy-indexing" class="headerlink" title="fancy indexing"></a>fancy indexing</h3><p>fancy index 返回值 通常是一个 copy。</p><ul><li><p>mask</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br>array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>mask = x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>mask<br>array([[ <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>],<br>       [<span class="hljs-literal">False</span>,  <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>]], dtype=<span class="hljs-built_in">bool</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x[mask]<br>array([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>])<br><span class="hljs-comment">## 测试返回的是copy 而不是 view</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x[mask][<span class="hljs-number">0</span>]=<span class="hljs-number">122</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br>array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>通过index选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x = np.arange(<span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>x<br>array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]])<br><span class="hljs-meta">&gt;&gt;&gt; </span>indices =[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>x[indices]<br>array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下清除显存占用</title>
    <link href="/blog/2018/05/12/2018-05-12-ubuntu/"/>
    <url>/blog/2018/05/12/2018-05-12-ubuntu/</url>
    
    <content type="html"><![CDATA[<ul><li><p>结束进程如果使用 <code>kill PID</code>的命令有时候的结果是，程序挂起。而并没有终止。此时显存仍处于占用状态。</p><p>应使用 <code>sudo kill PID</code></p><ul><li><p>如果是，程序挂起，显存在占用的状态。这时候<code>nvidia-smi</code>命令并不能找到其<code>PID</code>。这时候应使用 <code>fuser -v /dev/nvidia*</code> 显示而top没有显示的进程。</p></li><li><p>可以根据进程查看进程相关信息占用的内存情况，(进程号可以通过ps查看)如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -d 103767<br>103767:   python -u pairTaskCosFeatures_GPU.py --cuda 1<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep Mutual Learning</title>
    <link href="/blog/2018/05/03/2018-05-03-DML%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2018/05/03/2018-05-03-DML%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://drive.google.com/file/d/1Deg9xXqPKAlxRgmWbggavftTvJPqJeyp/view">paper</a></p><p><a href="https://github.com/YingZhangDUT/Deep-Mutual-Learning.git">offical code in TF</a></p><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/DML%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1.jpg" alt="DML"></p><p>DML 和模型蒸馏的不同之处在于，DML提供了一种无需预训练网络的知识迁移。可以应用在有监督学习，多模型协同学习，半监督学习等方面。</p><p>核心之处在于，使得两个网络的预测分布趋于一致。这里采用了KL散度作为模型的分布的度量标准。作者在实验中之处，无论是不对称的KL散度还是对称的JS散度，结果相差不大。</p><p>对于分类问题，$z_1$是模型输出的logits， 经过$softmax$层以后，等到预测概率。然后计算KL散度。和交叉熵损失函数。</p><h2 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h2><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/DML%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/2.jpg" alt="update_DML"></p><p>可以看到，这里的更新策略是，先计算模型的输出概率，根据模型1的损失函数，对模型1反向传播，梯度更新以后，计算模型1的输出概率，根据模型2的损失函数对模型2进行梯度更新。直到收敛。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>对于不同的情况，修改一下损失函数即可。</p><ol><li><p>多模型协同学习</p><p>对于K个模型</p><script type="math/tex; mode=display">L_{\Theta_k}=L_{C_k}+\frac{1}{K-1}\sum_{l=1,l\neq k}^{K}D_{KL}(p_l\Vert p_k)</script></li><li><p>半监督学习</p><p>KL散度的计算无需标签信息，所以也可以用于半监督学习。假设监督样本和无监督样本分别为 $\mathcal{L}$ 和 $\mathcal{U}$ ,那么$\mathcal{X}=\mathcal{L}  \bigcup \mathcal{U}$</p><p>​</p><script type="math/tex; mode=display">L_{\Theta_1}=\underset{x\in \mathcal{L}}{L_{C_1}}+\underset{x\in \mathcal{X}}{D_{KL}(p_2\Vert p_1})</script><p>​</p></li></ol><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/DML%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/3.jpg" alt="DML_result"></p><p>通过DML，获得了更好的泛化性能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>paper notes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Books Introduction</title>
    <link href="/blog/2018/04/20/2018-04-20-books_introduction/"/>
    <url>/blog/2018/04/20/2018-04-20-books_introduction/</url>
    
    <content type="html"><![CDATA[<p><strong>注：</strong> 关于常用命令环境的参考书目或者学习网站。</p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul><li><a href="http://billie66.github.io/TLCL/book/">the linux command line 中文版</a></li></ul><h2 id="Git-amp-GitHub"><a href="#Git-amp-GitHub" class="headerlink" title="Git &amp; GitHub"></a>Git &amp; GitHub</h2><ul><li><p>入门 </p><ul><li>书籍推荐 《GitHub 入门与实践》</li><li>在线网站 推荐 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰老师的教程</a></li></ul></li><li><p>深入了解</p><ul><li><p><a href="https://git-scm.com/book/zh/v2">Pro Git</a></p><p>多国语言可以任意阅读</p></li><li><p><a href="https://learngitbranching.js.org/">Learn Git Branching</a></p><p>可以到<code>git</code> 命令执行以后的 <code>git log graph</code>变化。了解<code>git</code>分支处理。</p><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/books_introduction/1.jpg" alt="learngitbranching"></p></li><li><p><a href="http://try.github.io">TryGit</a></p><p>只有英文版</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>熵和交叉熵</title>
    <link href="/blog/2018/04/13/2018-04-13-CrossEntrophy/"/>
    <url>/blog/2018/04/13/2018-04-13-CrossEntrophy/</url>
    
    <content type="html"><![CDATA[<p>熵的本质是香农信息量 $\log(1/p)$ 的期望。</p><p>现有关于样本集的2个概率分布 $p$ 和 $q$ ，其中$p$为真实分布，$q$非真实分布。按照真实分布$p$来衡量识别一个样本的所需要的编码长度的期望(即平均编码长度)为：$H(p)=\sum_{i}p(i)*\log(1/p(i))$。如果使用错误分布$q$来表示来自真实分布$p$的平均编码长度，则应该是：</p><script type="math/tex; mode=display">H(p,q)=\sum_{i} p(i)* \log(1/q(i))$$ 。因为用$q$来编码的样本来自分布$p$，所以期望$H(p,q)$中概率是$p(i)$。$H(p,q)$我们称之为**交叉熵**交叉熵公式</script><p>J(\theta)=-\frac{1}{N}\sum<em>{i=1}^N y^{(i)}\log(h</em>{\theta}(x^{(i)}))+(1-y^{(i)})\log(1-h_{\theta}(x^{(i)}))</p><script type="math/tex; mode=display">### KL散度(Kullback–Leibler divergence，KLD)根据非真实分布$q$得到的平均编码长度$H(p,q)$大于根据真实分布$p$得到的平均编码长度$H(p)$。事实上，根据[Gibbs' inequality](https://en.wikipedia.org/wiki/Gibbs%27_inequality)可知，$H(p,q)>=H(p)$恒成立，当$q$为真实分布$p$时取等号。我们将由$q$得到的平均编码长度比由$p$得到的平均编码长度多出的bit数称为“相对熵”：</script><p>\begin{aligned}<br>    D(p||q) &amp;= H(p,q)-H(p) \<br>                   &amp;=\sum_i p(i)  \times \log \frac{p(i)}{q(i)}<br>\end{aligned}</p><script type="math/tex; mode=display">其又被称为KL散度( [Kullback–Leibler divergence](https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence)，KLD)。它表示2个函数或概率分布的差异性：差异越大则相对熵越大，差异越小则相对熵越小，特别地，若2者相同则熵为0。### sigmoid cross-entropy### softmax cross-entropy#### softmax</script><p>y^{(i)}=\frac{e^{a<em>i}}{\sum</em>{k=1}^C e^{a_k}}</p><script type="math/tex; mode=display">#### softmax cross-entropy</script><p>loss = - \sum_{i=1}^N \log(y^{(i)})</p><p>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reinstall ubuntu</title>
    <link href="/blog/2018/04/12/2018-04-12-reinstall_ubuntu/"/>
    <url>/blog/2018/04/12/2018-04-12-reinstall_ubuntu/</url>
    
    <content type="html"><![CDATA[<ol><li><p>重装系统过程</p><p> 重装过程选择，略过 。以下为注意事项。</p><ol><li><p>更改ubuntu的源</p><p> 可以选择清华、交大、中科大的</p></li><li><p>​</p></li></ol></li><li><p>安装显卡驱动 </p><p> <strong>注：</strong> 这种安装方式在执行<code>sudo apt-get upgrade</code>命令以后，如果内核升级（linux下比较频繁）会使得驱动重新安装编译。慎重使用<code>sudo apt-get upgrade</code>命令</p><ol><li><p>下载安装</p><ol><li><p>禁用原来的驱动  </p><blockquote><p>sudo apt-get remove nvidia* &amp;&amp; sudo apt-get autoremove<br>sudo apt-get install dkms build-essential linux-headers-generic<br>sudo vim /etc/modprobe.d/blacklist.conf</p></blockquote></li><li><p>添加下面内容  </p><blockquote><p>blacklist nouveau<br>   blacklist lbm-nouveau<br>   options nouveau modeset=0<br>   alias nouveau off<br>   alias lbm-nouveau off</p></blockquote></li><li><blockquote><p>sudo update-initramfs -u</p></blockquote></li><li><p>检查是否卸载干净</p><blockquote><p>lsmod | grep nouveau<br>   lsmod | grep nvidia*</p></blockquote></li><li><p>重启</p><blockquote><p>reboot</p></blockquote></li><li><p><code>ctrl + alt + F1</code> 进入文本模式</p></li><li><p>关闭桌面</p><blockquote><p>sudo service lightdm stop</p></blockquote></li><li><p>安装 Nvidia Driver(需要提前下载好)</p><blockquote><p>sudo chmod 755 NVIDIA-Linux-x86_64-367.27.run<br>  sudo ./NVIDIA-Linux-x86_64-367.27.run</p></blockquote></li><li><p>打开桌面</p><blockquote><p>sudo service lightdm start</p></blockquote></li></ol></li><li><p>ppa模式</p><ul><li>a. to g. 与上面相同  </li></ul><ol><li><p>添加ppa源</p><blockquote><p>sudo add-apt-repository ppa:graphics-drivers/ppa  </p><pre><code> sudo apt-get update</code></pre></blockquote></li><li><p>选择安装合适的driver</p><blockquote><p>sudo apt-get install nvidia-</p></blockquote><p> 按 <code>TAB</code> 键选择</p></li></ol></li></ol></li><li><p>安装CUDA</p><ol><li><a href="https://developer.nvidia.com/cuda-downloads">这里</a>选择cuda 版本(此处为9.1)<br> 从官网下载 安装即可，注意不安装驱动（上面已经安装好了）</li><li><p>cuda 安装完成之后，在<code>~/.bashrc</code> 中添加以下环境变量即可。</p><blockquote><p>  export CUDA_HOME=/usr/local/cuda-9.1  </p><pre><code> export PATH=/usr/local/cuda-9.1/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;   export LD_LIBRARY_PATH=/usr/local/cuda-9.1/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;  </code></pre></blockquote></li><li><p><code>source ~/.bashrc</code> 生效</p></li><li><p><code>nvcc -V</code>检查安装情况</p><ul><li>编译<code>NVIDIA CUDA SAMPLES</code> examples失败 提示 <code>/usr/bin/ld:can not find -lgult</code>时 安装 <code>sudo apt-get install freeglut3 freeglut3-dev</code></li></ul></li><li><p>编译 <code>nvidia cuda samples</code></p></li></ol></li><li><p>安装 <code>anaconda</code></p><p> <strong>注：</strong> 强烈建议在不同的项目中建立不同的虚拟环境，避免不同的包污染。</p><blockquote><p>conda create -n python=<em>.</em></p></blockquote><p> ​</p><ol><li><p>添加环境变量，具体参照安装完后的提示。</p></li><li><p>添加 anaconda的源地址为<a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/">清华</a>的。</p></li><li><p><code>jupter notebook</code>  </p><ul><li><p>为了可以在<code>jupyter notebook</code> 中可以识别不同的虚拟环境, 需要安装包  </p><blockquote><p>conda install nb_conda  </p></blockquote></li><li><p><code>Permission Denied(13)</code>  </p><blockquote><p>sudo chown -R user anaconda3</p></blockquote></li><li><p>为了不同的环境均可以在<code>jupyter notebook</code>中识别，需要在每个环境安装包</p><blockquote><p>conda install ipykernel</p></blockquote></li><li><p>​</p></li></ul></li><li><p>​</p></li></ol></li><li><p>安装 <code>opencv</code>   </p><ol><li><p>如果只在<code>python</code>中使用<code>opencv</code>可以使用<code>conda install opencv</code>安装<code>python</code>的包。</p></li><li><p>编译opencv</p><p>注意opencv的版本要与cuda版本对应。</p></li><li><p>​</p><h4 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h4></li></ol></li><li><p>安装 <code>ss-qt5</code></p><blockquote><p>​</p></blockquote></li><li><p>安装 <code>sublime</code></p><p> 参照官网操作即好。</p></li><li><p>安装 <code>chrome</code></p></li><li><p>安装 <code>ROS</code> </p></li></ol><h4 id="Linux-平台下一些软件"><a href="#Linux-平台下一些软件" class="headerlink" title="Linux 平台下一些软件"></a>Linux 平台下一些软件</h4><ol><li><p>下载软件</p><ul><li><p><a href="https://github.com/persepolisdm/persepolis">Persepolis Download Manager</a></p><p>Persepolis Download Manager （以下简称 PDM）是著名命令行下载工具 Aria2 的一款零配置 GUI 客户端，即使你是对命令行一无所知的小白，也能轻松玩转。</p><p>首先介绍一下 Aria2，这是一款开源的跨平台下载工具，占用少、体积轻盈而功能强大，支持 HTTP、HTTPS、FTP、SFTP、BitTorrent 和 Metalink 等众多下载协议，是极客们的下载神器。</p><p>然而，Aria2 需要学习使用命令行操作，编写复杂的配置文件，门槛居高不下。而 PDM 就是专为大众打造的 Aria 图形界面客户端，它同样支持 Aria2 的各种功能，但是所有界面均直观易懂，推荐给想尝试 Aria2 的各位使用。</p></li></ul></li><li><p>​</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v2ray</title>
    <link href="/blog/2018/04/12/2018-04-12-v2ray/"/>
    <url>/blog/2018/04/12/2018-04-12-v2ray/</url>
    
    <content type="html"><![CDATA[<p>centos 7 安装 v2ray</p><h3 id="server端配置"><a href="#server端配置" class="headerlink" title="server端配置"></a>server端配置</h3><p>vps要求：</p><ul><li><p>在墙外，这没什么好说的</p></li><li><p>Arch、Ubuntu、CentOS，Debian都支持，最好是64位系统</p></li><li><p>服务器时间和你本地时间误差要在一分钟之类，否则会连不上，所以需要在连接之前对服务器进行时间校对</p><p><strong>服务器校时</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span>/apt -y install ntpdate<br><span class="hljs-attribute">ntpdate</span> time<span class="hljs-number">5</span>.aliyun.com<br></code></pre></td></tr></table></figure><p><strong>查看时区</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l <span class="hljs-regexp">/etc/</span>localtime<br><span class="hljs-regexp">//</span>lrwxrwxrwx <span class="hljs-number">1</span> root root <span class="hljs-number">27</span> Jan <span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">54</span> <span class="hljs-regexp">/etc/</span>localtime -&gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zoneinfo/</span>Etc/UTC<br></code></pre></td></tr></table></figure><p><strong>更改系统时区</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">rm -f <span class="hljs-regexp">/etc/</span>localtime<br>ln -s <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zoneinfo/</span>Asia<span class="hljs-regexp">/Shanghai /</span>etc/localtime<br></code></pre></td></tr></table></figure><p><strong>查看确认系统时间</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">date -R<br><span class="hljs-regexp">//</span>Wed, <span class="hljs-number">31</span> Jan <span class="hljs-number">2018</span> <span class="hljs-number">10</span>:<span class="hljs-number">00</span>:<span class="hljs-number">26</span> +<span class="hljs-number">0800</span><br></code></pre></td></tr></table></figure><p><strong>安装ufw</strong></p><p>ufw是linux下的防火墙配置工具，使用更加友好。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">yum/apt-<span class="hljs-builtin-name">get</span> install ufw<br></code></pre></td></tr></table></figure><p>​</p><p>​</p></li></ul><h3 id="server端安装"><a href="#server端安装" class="headerlink" title="server端安装"></a>server端安装</h3><p>Linux服务器下面命令基本一样。这里的安装方式跟<a href="https://www.v2ray.com/chapter_00/install.html">官方教程一样</a></p><p><code>bash &lt;(curl -L -s https://install.direct/go.sh)</code></p><p><strong>启动服务并且查看服务状态</strong></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">systemctl start v2ray<br>systemctl status v2ray<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs smali">v2ray.service - V2Ray Service<br>Loaded: loaded (/etc/systemd/system/v2ray.service; enabled; vendor preset: enabled)<br>Active: active (running) since Wed 2018-01-31 00:32:29 UTC; 8h ago<br>Main PID: 2392 (v2ray)<br>Tasks: 7<br>Memory: 5.6M<br>CPU: 4.512s<br>CGroup: /system.slice/v2ray.service<br>└─2392 /usr/bin/v2ray/v2ray -config /etc/v2ray/config.json<br><br>Jan 31 00:32:29<span class="hljs-built_in"> instance-5 </span>systemd[1]: Started V2Ray Service.<br>Jan 31 00:32:29<span class="hljs-built_in"> instance-5 </span>v2ray[2392]: V2Ray v3.6 (die Commanderin) 20180112<br>Jan 31 00:32:29<span class="hljs-built_in"> instance-5 </span>v2ray[2392]: An unified platform for anti-censorship.<br></code></pre></td></tr></table></figure><p>配置文件等客户端结束以后再进行配置。</p><h3 id="客户端下载及配置"><a href="#客户端下载及配置" class="headerlink" title="客户端下载及配置"></a>客户端下载及配置</h3><p>下载一般包括两部分，core程序和GUI程序</p><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p><a href="https://www.v2ray.com/chapter_00/install.html">core</a></p><p><a href="https://github.com/2dust/v2rayN/releases">GUI</a></p><p>将下载好的core和GUI程序解压到同一文件夹下。打开GUI程序。</p><p><img src="http://ww1.sinaimg.cn/mw690/007arC1sly1g0wf0d59cdj30ya0j6mxp.jpg" alt="GUI界面"></p><p>选择服务器-&gt; 添加vmess服务器（或者shadowsocks服务器）。</p><p><img src="http://ww1.sinaimg.cn/mw690/007arC1sly1g0wf0x8bb7j30kf0e6jrm.jpg" alt="config"></p><p>填入vps的地址，期望的端口。生成一个id。其余的可以不填。确定以后可以看到服务器列表中有了你的服务器。</p><p>然后选中你的服务器，右键-&gt;导出所选服务器为服务端配置。</p><p>会提示保存一个文件。存为<code>config.json</code></p><h4 id="OS-X"><a href="#OS-X" class="headerlink" title="OS X"></a>OS X</h4><p><a href="https://www.v2ray.com/chapter_00/install.html">core</a></p><p><a href="https://github.com/Cenmrev/V2RayX">GUI</a></p><p>基本如上。由于没有mac电脑。请参阅GUI repo的readme文档</p><h4 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h4><p>暂时没有GUI程序。配置情况与服务器基本相同。</p><h3 id="server端配置-1"><a href="#server端配置-1" class="headerlink" title="server端配置"></a>server端配置</h3><ul><li>ssh连接到vps， 目录切换到 <code>\etc\v2ray</code></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> /etc/v2ray<br><span class="hljs-keyword">vi</span> config.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>按<code>i</code>进入编辑模式，删除所有内容，将上面保存的<code>config.json</code>的内容复制到这里。（注意windows和linux两个系统行尾符不一致，如果你用的是windows系统，再notepad++中将行尾符转为unix格式再进行复制）</p><p>复制结束以后，查看一下内容是否完全复制到vps的设置文件中了。</p><p>按<code>esc</code>键，<code>vi</code>中<code>ctrl+F</code> 和<code>ctrl+B</code> 分别进行下翻页和上翻页。输入 <code>:wq</code>保存退出。</p><ul><li>如果是用<code>winscp</code> 登陆到服务器，可以直接把文件上传到这个文件夹下，替换就好。</li></ul><p>开启防火墙端口</p><p><code>ufw allow -port</code></p><p>这里的<code>-port</code>替换为上面你设置的端口。</p><p>重启<code>v2ray</code>服务。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">service</span> v<span class="hljs-number">2</span>ray restart<br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在你的客户端上，右键测试延迟。如果没有问题，就能看到延迟时间了。然后将其设置为活动服务器。</p><h3 id="浏览器设置"><a href="#浏览器设置" class="headerlink" title="浏览器设置"></a>浏览器设置</h3><p>使用SwitchOmega设置PAC</p><h3 id="Proxifer设置"><a href="#Proxifer设置" class="headerlink" title="Proxifer设置"></a>Proxifer设置</h3><p>设置不同程序是否使用代理</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p>FUCK GFW。</p>]]></content>
    
    
    
    <tags>
      
      <tag>GFW</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git decline</title>
    <link href="/blog/2018/04/06/2018-4-12-git%20decline/"/>
    <url>/blog/2018/04/06/2018-4-12-git%20decline/</url>
    
    <content type="html"><![CDATA[<p><strong>问题描述</strong>        </p><blockquote><p>[remote rejected] master -&gt; master (pre-receive hook declined)<br>error: failed to push some refs to ‘git@github.com:<em>**</em>/FCN-in-the-wild.git’</p></blockquote><p><strong>原因</strong></p><blockquote><p>所push的分支权限为protected,只有项目的管理员或者项目的管理员指派的具有相应权限的人才能进行push,要进行项目的push</p><p>这个文件是从其他位置复制过来的，权限上存在问题。</p></blockquote><p><strong>解决方法</strong></p><ol><li><p><strong>将所要push的内容所在的分支的protected权限关闭</strong></p><ol><li>进入所在项目的settings</li></ol></li><li><p><strong>新建其它分支，将项目push到新建的分支上，后期再进行merge</strong></p><ol><li><p>新建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch 分支名<br></code></pre></td></tr></table></figure></li><li><p>切换分支</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> checkout 分支名<br></code></pre></td></tr></table></figure></li><li><p>项目上传</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">add </span>.<br><br>git commit -m <span class="hljs-string">&quot;提交的信息&quot;</span><br><br>git remote <span class="hljs-keyword">add </span><span class="hljs-keyword">origin </span>远程仓库地址<br><br>git push -u <span class="hljs-keyword">origin </span>分支名<br></code></pre></td></tr></table></figure></li></ol></li></ol><pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout master<br>git merge hotfix<br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语义分割中的度量标准</title>
    <link href="/blog/2018/04/06/2017-03-03-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E5%BA%A6%E9%87%8F/"/>
    <url>/blog/2018/04/06/2017-03-03-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E5%BA%A6%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="pixel-accuracy-PA，像素精度"><a href="#pixel-accuracy-PA，像素精度" class="headerlink" title="pixel accuracy (PA，像素精度)"></a>pixel accuracy (PA，像素精度)</h1><p>标记正确的像素占总像素的比例</p><script type="math/tex; mode=display">PA=\frac{\sum_{i=1}^kp_{ii}}{\sum_{i=0}^k\sum_{j=0}^kp_{ij}}</script><h1 id="mean-pixel-accuracy-MPA-均像素精度"><a href="#mean-pixel-accuracy-MPA-均像素精度" class="headerlink" title="mean pixel accuracy (MPA, 均像素精度)"></a>mean pixel accuracy (MPA, 均像素精度)</h1><p>计算每个类中被正确分类像素的比例，然后平均</p><script type="math/tex; mode=display">MPA=\frac{1}{k+1}\sum_{i=0}^{k}\frac{p_{ii}}{\sum_{j=0}^kp_{ij}}</script><h1 id="Mean-Intersection-over-Union-MIoU-均交并比"><a href="#Mean-Intersection-over-Union-MIoU-均交并比" class="headerlink" title="Mean Intersection over Union(MIoU, 均交并比)"></a>Mean Intersection over Union(MIoU, 均交并比)</h1><p>语义分割标准度量。计算两个集合的交集和并集之比。在semantic segmentation中，为真实值（ground truth）与预测值（predicted segmentation）的比值。这个比例变形为正真数（intersection）比上真正、假负、假正（并集）之和。在每个类上计算IoU，平均。</p><script type="math/tex; mode=display">MIoU=\frac{1}{k+1}\sum_{i=0}^k\frac{p_{ii}}{\sum_{j=0}^k p_{ij}+\sum_{j=0}^kp_{ji}-p_{ii}}</script><p><img src="https://tuchuang-1259359185.cos.ap-chengdu.myqcloud.com/_asserts/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E5%BA%A6%E9%87%8F/1.jpg" alt="miou"></p><h1 id="Frequency-Weight-Intersection-over-Union-FWIoU-频权交并比"><a href="#Frequency-Weight-Intersection-over-Union-FWIoU-频权交并比" class="headerlink" title="Frequency Weight Intersection over Union(FWIoU, 频权交并比)"></a>Frequency Weight Intersection over Union(FWIoU, 频权交并比)</h1><p>MIoU的提升。根据每个类出现的频率设置权重</p><script type="math/tex; mode=display">FWIoU=\frac{1}{\sum_{i=0}^k\sum_{j=0}^kp_{ij}}\sum_{i=0}^k\frac{p_{ii}}{\sum_{j=0}^k\sum_{j=0}^kp_{ji}-p_{ii}}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#计算label_true和label_pred对应相同的就在矩阵中对应坐标加1。a和b保存着各个像素的分的类别</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_fast_hist</span>(<span class="hljs-params">label_true, label_pred, n_class</span>):</span><br>    <span class="hljs-comment">#过滤掉多余的分类</span><br>    mask = (label_true &gt;= <span class="hljs-number">0</span>) &amp; (label_true &lt; n_class)<br>    <span class="hljs-comment">#bincount用于统计在范围内出现的个数，即直方图，如果不够n^2个，</span><br>    <span class="hljs-comment">#那就填充到n^2，这样可以reshpe为n*n的矩阵，正好表示分割图和正确标记图在相同</span><br>    <span class="hljs-comment">#类别上像素出现的个数</span><br>    hist = np.bincount(<br>        n_class * label_true[mask].astype(<span class="hljs-built_in">int</span>) +<br>        label_pred[mask], minlength=n_class ** <span class="hljs-number">2</span>).reshape(n_class, n_class)<br>    <span class="hljs-keyword">return</span> hist<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">label_accuracy_score</span>(<span class="hljs-params">label_trues, label_preds, n_class</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Returns accuracy score evaluation result.</span><br><span class="hljs-string">      - overall accuracy</span><br><span class="hljs-string">      - mean accuracy</span><br><span class="hljs-string">      - mean IU</span><br><span class="hljs-string">      - fwavacc</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    hist = np.zeros((n_class, n_class))<br>    <span class="hljs-keyword">for</span> lt, lp <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(label_trues, label_preds):<br>        hist += _fast_hist(lt.flatten(), lp.flatten(), n_class)<br>    acc = np.diag(hist).<span class="hljs-built_in">sum</span>() / hist.<span class="hljs-built_in">sum</span>()<br>    acc_cls = np.diag(hist) / hist.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>)<br>    acc_cls = np.nanmean(acc_cls)<br>    iu = np.diag(hist) / (hist.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) + hist.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>) - np.diag(hist))<br>    mean_iu = np.nanmean(iu)<br>    freq = hist.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>) / hist.<span class="hljs-built_in">sum</span>()<br>    fwavacc = (freq[freq &gt; <span class="hljs-number">0</span>] * iu[freq &gt; <span class="hljs-number">0</span>]).<span class="hljs-built_in">sum</span>()<br>    <span class="hljs-keyword">return</span> acc, acc_cls, mean_iu, fwavacc<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Deep Learning</tag>
      
      <tag>Semantic Segmentation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>House Robber 打家劫舍</title>
    <link href="/blog/2018/02/06/2019-03-10-House%20Robber/"/>
    <url>/blog/2018/02/06/2019-03-10-House%20Robber/</url>
    
    <content type="html"><![CDATA[<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><blockquote><p>相邻的两个房子一个晚上内被偷，讲触发报警。</p></blockquote><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p><blockquote><p>输入为非负元素的列表，其中元素表示每家的金额。输出为一夜可以偷到的最大数目的金钱。</p><p>Example 1:<br>   Input: [1,2,3,1]<br>   Output: 4</p><p>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>            Total amount you can rob = 1 + 3 = 4.<br>Example 2:</p><p>​    Input: [2,7,9,3,1]<br>​    Output: 12<br>Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br>​             Total amount you can rob = 2 + 9 + 1 = 12.</p></blockquote><p>这个题目实际上就是<strong>数组非连续元素求最大值</strong>。考虑使用动态规划的方法求解。</p><p>首先找到递归方程。 </p><script type="math/tex; mode=display">F(n) = \max(F(n-2)+v_n, F(n-1))</script><p>初始化条件，$F(1)=v_1, \quad F(2)=\max(v_1,v_2)$</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;=<span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums)<br>        result = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>        result[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        result[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> idx, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums[<span class="hljs-number">2</span>:]):<br>            value = <span class="hljs-built_in">max</span>(result[idx]+item, result[idx+<span class="hljs-number">1</span>])<br>            result.append(value)<br>        <span class="hljs-keyword">return</span> result[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>空间可以是<code>O(1)</code>复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>):</span><br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums:<br>        a, b = b, <span class="hljs-built_in">max</span>(a + x, b)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a, b)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MedianofTwoSortedArrays</title>
    <link href="/blog/2017/04/25/2017-04-25-midianValue2sortedArray/"/>
    <url>/blog/2017/04/25/2017-04-25-midianValue2sortedArray/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>在两个排序数组中，找到其中位数</p></blockquote><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>可以考虑将两个数组归并排序，然后求得中位数。时间复杂度 $O(m+n)$ ，空间复杂度$O(m+n)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">nums1, nums2</span>):</span><br>    a,b = <span class="hljs-built_in">sorted</span>((nums1,nums2), key=<span class="hljs-built_in">len</span>)<br>    i,j,m,n = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(a),<span class="hljs-built_in">len</span>(b)<br>    newNums = []<br>    <span class="hljs-keyword">while</span> i&lt;m <span class="hljs-keyword">and</span> j&lt;n:<br>        <span class="hljs-keyword">if</span> a[i] &lt; b[j]:<br>            nums.append(a[i])<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            nums.append(b[j])<br>            j += <span class="hljs-number">1</span><br>    nums.append(a[i:])<br>    nums.append(b[j:])<br>    <span class="hljs-keyword">return</span> nums<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMidian</span>(<span class="hljs-params">nums1, nums2</span>):</span><br>    nums = merge(nums1, nums2)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)&amp;<span class="hljs-number">1</span> == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> (nums[<span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>]+nums[<span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>-<span class="hljs-number">1</span>])/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>二分查找。</p><blockquote><p>中位数是指数组两边以此分界，两边的元素个数相等。</p></blockquote><p>即<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">    <span class="hljs-selector-tag">left_part</span>            |        <span class="hljs-selector-tag">right_part</span><br><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[0]</span>, <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[1]</span>, ..., <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[i-1]</span>  |  <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[i]</span>, <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[i+1]</span>, ..., <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[m-1]</span><br><span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[0]</span>, <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[1]</span>, ..., <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[j-1]</span>  |  <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[j]</span>, <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[j+1]</span>, ..., <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[n-1]</span><br></code></pre></td></tr></table></figure><br>所以如果能把两个数组分别分成两部分，并满足条件</p><ul><li>len(left_part) = len(right_part)</li><li>max(left_part) ≤ min(right_part)</li></ul><p>那么最终的中位数就是</p><script type="math/tex; mode=display">median= \frac{\max(left\_part)+\min(right\_part)}{2}</script><p>所以需要保证：</p><ul><li>$i+j=m−i+n−j$ (or: $m - i + n - j + 1$)<br>  if $n≥m$, we just need to set:<br>  $i=0∼m,j=(m+n+1)/2 −i$</li><li>$B[j−1]≤A[i]$ and $A[i−1]≤B[j]$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedianSortedArrays</span>(<span class="hljs-params">self, nums1: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>],nums2: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>  a, b = <span class="hljs-built_in">sorted</span>((nums1, nums2), key=<span class="hljs-built_in">len</span>)<br>  <span class="hljs-comment"># a 短数组 b 长数组</span><br>  m, n = <span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(b)<br>  after = (m + n - <span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>  lo, hi = <span class="hljs-number">0</span>, m<br>  <span class="hljs-keyword">while</span> lo &lt; hi:<br>    i = (lo + hi) // <span class="hljs-number">2</span><br>    <span class="hljs-comment"># b[0:after-i] 长数组 left</span><br>    <span class="hljs-keyword">if</span> after-i-<span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> a[i] &gt;= b[after-i-<span class="hljs-number">1</span>]:<br>      hi = i<br>    <span class="hljs-keyword">else</span>:<br>      lo = i + <span class="hljs-number">1</span><br>  i = lo<br>  nextfew = <span class="hljs-built_in">sorted</span>(a[i:i+<span class="hljs-number">2</span>] + b[after-i:after-i+<span class="hljs-number">2</span>])<span class="hljs-comment">##??</span><br>  <span class="hljs-keyword">return</span> (nextfew[<span class="hljs-number">0</span>] + nextfew[<span class="hljs-number">1</span> - (m+n)%<span class="hljs-number">2</span>]) / <span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>binarySearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
