

这部分介绍了虚拟内存的概念，为什么需要虚拟内存，虚拟内存背后的页表机制。

## 虚拟内存
虚拟内存是对实际物理内存的映射，通过页表机制，将实际的物理地址（physical address，PA）映射到虚拟地址（virtual address，VA）。

- 通过虚拟内存，每个进程都可以有独立的地址空间。通过地址管理单元（Memory Management Unit，MMU）或者其他的技术，可以将每个进程的虚拟地址空间映射到物理内存地址。虚拟地址的低bit基本一样，所以映射是以块为单位进行，同时性能也很好。
- 虚拟地址可以让我们对进程隐藏物理地址。通过一些聪明的操控，我们可以读写虚拟地址，最后实际读写物理地址。
- 虚拟内存对于隔离性来说是非常基础的。每个进程都可以认为自己有独立的内存可以使用。

## 地址空间
地址空间其实就是地址的寻址范围与实际物理内存的最小值，最高支持的寻址范围与操作系统的位数有关。如`32`位的系统，一个指针大小是4字节，范围是` 0x00000000~0xFFFFFFFF`，最大值 `0xFFFFFFFF` 表示的即为 4GB大小的容量。

在实际应用运行的时候，不同程序应该占用不同的内存空间。各个程序相互隔离，不能影响其他程序的运行。

为保证这种不同程序之间的隔离性，需要一种内存管理机制。最常见的解决方法就是页表。

## 内存管理机制
### 页表
为了保证各个进程的独立性，相互之间的内存独立性，操作系统引入了页表（page table）。之后，CPU执行命令时，读取的地址就是一个虚拟地址，由内存管理单元（MMU，Memory Management Unit）负责将其翻译为一个物理地址。

![](mmu.png)

为了支持MMU的翻译工作，就需要一个映射表来记录虚拟地址到真实地址的映射关系。这个表单完成了`VA->PA`的映射关系。

这个表单是存在内存中的，MMU负责从内存中读取这个表单。对每个地址创建一条映射很不划算，会导致大量的内存占用。实际中是将内存分页，为每个page创建一条条目（page table entry， PTE）。

为了能够找到对应的地址，虚拟地址的结构分为两部分，page的索引以及页内偏移offset。

![](va2pa.png?50)

而RISC-V中，一个page是4KB，(也就是 4096 Bytes，这样page内索引一个地址需要12个bit）。

> 注：
> 1. 内存地址对应关系的表单(页表）也保存在内存中。所以CPU中需要有一些寄存器用来存放表单在物理内存中的地址。那么在RISC-V上一个叫做SATP的寄存器会保存这个地址。
> 2. 每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单
> 3. SATP寄存器会根据进程而修改，每个进程对应的SATP值是由内核保存的
> 4. 内核会写SATP寄存器，写SATP寄存器是一条特殊权限指令。只有运行在kernel mode的代码可以更新这个寄存器。

### 多级页表

xv6是给予RISC-V的64位系统，虚拟地址大小是64位。实际上，RSIC-V处理器上，并不是所有的64bit都被使用了，高25bit并没有被使用。虚拟内存地址的数量现在只有`2^39`个，大概是`512GB`。

在RISC-V中，物理内存地址是`56bit`。所以物理内存可以大于单个虚拟内存地址空间，但是也最多到`2^56`。其中`44bit`是物理page号（PPN，Physical Page Number），剩下`12bit`是offset完全继承自虚拟内存地址（也就是地址转换时，只需要将虚拟内存中的`27bit`翻译成物理内存中的`44bit`的page号，剩下的12bitoffset直接拷贝过来即可）。

page table大小为`2^27`, 以`64 bit`系统为例，这就需要 `2^27*64/8/1024/1024=1024MB`大小的物理内存。这样内存占用的开销太大。

在实际中，页表并不是作为一个包含了$2^{27}$个PTE的大列表存储在物理内存中的，而是采用了三级树状的形式进行存储，这样可以让页表分散存储。每个页表就是一页。第一级页表是一个4096字节的页，包含了512个PTE（因为每个PTE需要8字节），每个PTE存储了下级页表的页物理地址，第二级列表由512个页构成，第三级列表由512*512个页构成。因为每个进程虚拟地址的高27位用来确定PTE，对应到3级页表就是最高的9位确定一级页表PTE的位置，中间9位确定二级页表PTE的位置，最低9位确定三级页表PTE的位置。如下图所示。第一级根页表的物理页地址存储在satp寄存器中，每个进程拥有自己独立的satp。

![](multi-pages.png?50)

> PTE flag可以告诉硬件这些相应的虚拟地址怎样被使用，比如PTE_V表明这个PTE是否存在，PTE_R、PTE_W、PTE_X控制这个页是否允许被读取、写入和执行，PTE_U控制user mode是否有权访问这个页，如果PTE_U=0，则只有supervisor mode有权访问这个页。


#### 查找过程

首先从satp中读取第一集页表的位置(PA)，加载到内存，根据L2的索引(9bit)读取`PPN1`(44bit)，找到下一级L1表单地址(`PPN1<<12+0x000`)，加载L1 page table到内存，根据L1的索引(9bit)读取`PPN2`，查找L0表单地址PPN0(`PPN2<<12+0x000`)，根据L0索引得到物理地址页表（PA，44bit）加上offset（12bit）计算到物理内存地址。

从某种程度上来说，多级页表与使用一级页表索引相比基本一样。除了实际的索引是由3步，而不是1步完成。这种方式的主要优点是，如果地址空间中大部分地址都没有使用，你不必为每一个index准备一个条目。


> 我想知道我们是怎么计算page table的物理地址？
Frans教授：我们不会加上虚拟地址中的offset，这里只是使用了12bit的0。所以我们用44bit的PPN，再加上12bit的0，这样就得到了下一级page directory的56bit物理地址。这里要求每个page directory都与物理page对齐（也就是page directory的起始地址就是某个page的起始地址，所以低12bit都为0）

### 页表缓存
 页表缓存（Translation Lookaside Buffer，TLB）是为了避免频繁读取页表导致的计算性能下降。
 
 试想一下，如果每次读取，都需要进行这样的多级页表转换，CPU需要一直等待MMU，带来的时间成本比较大。如果把上一次读取的内容缓存下来，避免重复读取DDR内存，可以大大降低等待时间。这就是TLB的作用。
![](tlb.png?70)


## kernel page table

下面介绍一下，页表是如何工作的


## linux的多级页表


- {% post_link 公开课/mit6s081/labs/lab03_pgtbl lab03_页表实验 %}

